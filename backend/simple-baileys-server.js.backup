const express = require('express');
const cors = require('cors');
const { createServer } = require('http');
const { Server } = require('socket.io');
// Importar fetch para download de m√≠dias
const fetch = require('node-fetch');
// Importar Baileys dinamicamente
let makeWASocket, DisconnectReason, useMultiFileAuthState, Boom, downloadMediaMessage, jidNormalizedUser;
const crypto = require('crypto');
const fs = require('fs');
const path = require('path');
const { createClient } = require('@supabase/supabase-js');
const { mapToDbRow } = require('./message-normalizer');
const ContactInfoExtractor = require('./contact-info-extractor');
const WhatsAppProfileSyncService = require('./whatsapp-profile-sync.service');

// Load environment variables
require('dotenv').config({ path: './env.supabase' });

// Supabase configuration
const supabaseUrl = process.env.SUPABASE_URL || 'https://nrbsocawokmihvxfcpso.supabase.co';
const supabaseKey = process.env.SUPABASE_ANON_KEY || 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im5yYnNvY2F3b2ttaWh2eGZjcHNvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY0NzQwNTMsImV4cCI6MjA3MjA1MDA1M30.3SxEVRNNBHhAXgJ7S2BMHm1QWq9kxYamuLjvZm0_OU0';
const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY || 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im5yYnNvY2F3b2ttaWh2eGZjcHNvIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc1NjQ3NDA1MywiZXhwIjoyMDcyMDUwMDUzfQ.w6EJDzQj1fffHJ4lYzOVDLydqhbhGOW5KtGBDjaHfPA';

const supabase = createClient(supabaseUrl, supabaseKey);
const supabaseAdmin = createClient(supabaseUrl, supabaseServiceKey);

// Inicializar servi√ßo de sincroniza√ß√£o de perfil
const profileSyncService = new WhatsAppProfileSyncService(supabaseUrl, supabaseServiceKey);

const app = express();
const server = createServer(app);
const io = new Server(server, {
  cors: {
    origin: ["http://localhost:5173", "http://localhost:5174"],
    methods: ["GET", "POST"]
  }
});

// Importar PortFinder para detec√ß√£o autom√°tica de portas
const PortFinder = require('../port-finder');

// Fun√ß√£o para encontrar porta dispon√≠vel com limpeza autom√°tica
async function findAvailablePort() {
  const finder = new PortFinder();
  try {
    // Primeiro, tentar sem limpeza agressiva
    let ports = await finder.findPorts(false);
    return ports.backend;
  } catch (error) {
    console.warn('‚ö†Ô∏è Erro na detec√ß√£o normal, tentando limpeza agressiva...', error.message);
    
    try {
      // Se falhar, tentar com limpeza agressiva
      const ports = await finder.findPorts(true);
      return ports.backend;
    } catch (aggressiveError) {
      console.error('‚ùå Erro mesmo com limpeza agressiva, usando porta padr√£o:', aggressiveError.message);
      return process.env.PORT || 3000;
    }
  }
}

let PORT = process.env.PORT || 3001; // Usar porta 3001 por padr√£o

// Middlewares
app.use(cors({
  origin: ["http://localhost:5173", "http://localhost:5174"],
  credentials: true
}));
app.use(express.json());

// Multer para upload de arquivos
const multer = require('multer');
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    const uploadPath = path.join(__dirname, 'uploads', 'temp');
    if (!fs.existsSync(uploadPath)) {
      fs.mkdirSync(uploadPath, { recursive: true });
    }
    cb(null, uploadPath);
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname));
  }
});

const upload = multer({ 
  storage,
  limits: { fileSize: 50 * 1024 * 1024 }, // 50MB
  fileFilter: (req, file, cb) => {
    console.log('üîç [FILE-FILTER] Verificando arquivo:', {
      originalname: file.originalname,
      mimetype: file.mimetype,
      extname: path.extname(file.originalname).toLowerCase()
    });
    
    // Tipos permitidos - sendo mais permissivo com √°udios
    const allowedTypes = /jpeg|jpg|png|gif|mp4|avi|mov|mp3|wav|ogg|webm|pdf|doc|docx|txt|xlsx|xls/;
    const extname = allowedTypes.test(path.extname(file.originalname).toLowerCase());
    const mimetype = allowedTypes.test(file.mimetype);
    
    // Verificar se √© √°udio de qualquer tipo
    const isAudio = file.mimetype.startsWith('audio/') || 
                   file.originalname.includes('recording') ||
                   file.originalname.includes('audio') ||
                   /\.(webm|ogg|mp3|wav|mp4|m4a)$/i.test(file.originalname);
    
    // Verificar se √© v√≠deo
    const isVideo = file.mimetype.startsWith('video/') ||
                   /\.(mp4|avi|mov|webm|mkv)$/i.test(file.originalname);
    
    // Verificar se √© imagem
    const isImage = file.mimetype.startsWith('image/') ||
                   /\.(jpg|jpeg|png|gif|webp)$/i.test(file.originalname);
    
    // Verificar se √© documento
    const isDocument = /\.(pdf|doc|docx|txt|xlsx|xls)$/i.test(file.originalname);
    
    if (isAudio || isVideo || isImage || isDocument || (mimetype && extname)) {
      console.log('‚úÖ [FILE-FILTER] Arquivo permitido:', {
        isAudio,
        isVideo,
        isImage,
        isDocument,
        mimetype: file.mimetype,
        originalname: file.originalname
      });
      return cb(null, true);
    } else {
      console.log('‚ùå [FILE-FILTER] Arquivo n√£o permitido:', {
        extname,
        mimetype: file.mimetype,
        originalname: file.originalname,
        isAudio,
        isVideo,
        isImage,
        isDocument
      });
      cb(new Error('Tipo de arquivo n√£o permitido'));
    }
  }
});

// Importar OpenAI para funcionalidades de IA
const OpenAI = require('openai');

// Rotas de IA
app.post('/api/ai/process-text', async (req, res) => {
  try {
    const { prompt, model = 'gpt-4o-mini', apiKey } = req.body;

    if (!prompt || !apiKey) {
      return res.status(400).json({ 
        error: 'Prompt e API key s√£o obrigat√≥rios' 
      });
    }

    // Validar formato da API key
    if (!apiKey.startsWith('sk-')) {
      return res.status(400).json({ 
        error: 'API Key inv√°lida' 
      });
    }

    // Inicializar OpenAI
    const openai = new OpenAI({
      apiKey: apiKey
    });

    // Fazer requisi√ß√£o para OpenAI
    const completion = await openai.chat.completions.create({
      model: model,
      messages: [
        {
          role: 'system',
          content: 'Voc√™ √© um assistente de texto especializado em melhorar, corrigir e processar textos. Sempre responda APENAS com o texto processado, sem explica√ß√µes adicionais ou coment√°rios. Mantenha o tom e estilo da mensagem original. Use aspas naturalmente quando apropriado no texto.'
        },
        {
          role: 'user',
          content: prompt
        }
      ],
      max_tokens: 1000,
      temperature: 0.3
    });

    const processedText = completion.choices[0]?.message?.content || '';

    res.json({
      success: true,
      text: processedText.trim()
    });

  } catch (error) {
    console.error('Erro ao processar texto com IA:', error);
    
    // Tratar erros espec√≠ficos da OpenAI
    if (error.code === 'invalid_api_key') {
      return res.status(401).json({ 
        error: 'API Key inv√°lida' 
      });
    }
    
    if (error.code === 'insufficient_quota') {
      return res.status(402).json({ 
        error: 'Cota da API excedida' 
      });
    }

    res.status(500).json({ 
      error: 'Erro interno do servidor' 
    });
  }
});

// Verificar status da API key
app.post('/api/ai/check-api-key', async (req, res) => {
  try {
    const { apiKey } = req.body;

    if (!apiKey) {
      return res.status(400).json({ 
        error: 'API key √© obrigat√≥ria' 
      });
    }

    // Validar formato da API key
    if (!apiKey.startsWith('sk-')) {
      return res.status(400).json({ 
        error: 'API Key inv√°lida' 
      });
    }

    // Inicializar OpenAI
    const openai = new OpenAI({
      apiKey: apiKey
    });

    // Fazer uma requisi√ß√£o simples para verificar a API key
    const models = await openai.models.list();

    res.json({
      success: true,
      valid: true,
      models: models.data.map(model => ({
        id: model.id,
        owned_by: model.owned_by
      }))
    });

  } catch (error) {
    console.error('Erro ao verificar API key:', error);
    
    res.json({
      success: false,
      valid: false,
      error: error.message
    });
  }
});

// Armazenar conex√µes ativas
const activeConnections = new Map();
// Contador de tentativas de reconex√£o por conex√£o
const reconnectionAttempts = new Map();
const MAX_RECONNECTION_ATTEMPTS = 3;

// Fun√ß√£o para buscar usu√°rio ativo (session_status = 'connected')
async function getActiveUser() {
  try {
    const { data: activeUser, error } = await supabaseAdmin
      .from('profiles')
      .select('id, email, name')
      .eq('session_status', 'connected')
      .maybeSingle();
    
    if (error) {
      console.error('‚ùå Erro ao buscar usu√°rio ativo:', error);
      return null;
    }
    
    if (!activeUser) {
      console.error('‚ùå Nenhum usu√°rio ativo encontrado (session_status = connected)');
      return null;
    }
    
    console.log(`üë§ Usu√°rio ativo encontrado: ${activeUser.email} (${activeUser.id})`);
    return activeUser;
  } catch (error) {
    console.error('‚ùå Erro ao buscar usu√°rio ativo:', error);
    return null;
  }
}

// Helpers para envio de mensagens
function ensureJid(chatId) {
  if (!chatId) throw new Error('chatId required');
  
  console.log('üîç [ENSURE-JID] Processando chatId:', chatId);
  
  try {
    let normalizedJid;
    
    // Fun√ß√£o de normaliza√ß√£o pr√≥pria para evitar depend√™ncia do Baileys
    const normalizeJid = (jid) => {
      if (!jid) return null;
      
      // Se j√° tem @, verificar se est√° no formato correto
      if (jid.includes('@')) {
        // Se termina com @c.us, converter para @s.whatsapp.net
        if (jid.endsWith('@c.us')) {
          return jid.replace('@c.us', '@s.whatsapp.net');
        }
        // Se j√° termina com @s.whatsapp.net, retornar como est√°
        if (jid.endsWith('@s.whatsapp.net')) {
          return jid;
        }
        // Se tem @ mas n√£o √© um dos formatos conhecidos, assumir que √© @s.whatsapp.net
        return jid;
      }
      
      // Se √© apenas n√∫meros, adicionar @s.whatsapp.net
      if (/^\d+$/.test(jid)) {
        return `${jid}@s.whatsapp.net`;
      }
      
      // Para outros casos, adicionar @s.whatsapp.net
      return `${jid}@s.whatsapp.net`;
    };
    
    if (/^\d+$/.test(chatId)) {
      normalizedJid = normalizeJid(`${chatId}@s.whatsapp.net`);
    } else if (/@c\.us$/.test(chatId)) {
      normalizedJid = normalizeJid(chatId.replace('@c.us', '@s.whatsapp.net'));
    } else {
      normalizedJid = normalizeJid(chatId);
    }
    
    console.log('‚úÖ [ENSURE-JID] JID normalizado:', normalizedJid);
    return normalizedJid;
  } catch (error) {
    console.error('‚ùå [ENSURE-JID] Erro ao normalizar JID:', error);
    console.error('‚ùå [ENSURE-JID] chatId original:', chatId);
    throw new Error(`Erro ao normalizar JID: ${error.message}`);
  }
}

async function getSessionInfo(connectionId, supabase) {
  const { data, error } = await supabase
    .from('whatsapp_sessions')
    .select('owner_id, phone')
    .eq('connection_id', connectionId)
    .order('connected_at', { ascending: false })
    .limit(1)
    .maybeSingle();
  if (error) throw error;
  return { ownerId: data?.owner_id ?? null, connectionPhone: data?.phone ?? null };
}

// Fun√ß√£o para atualizar contato com dados da mensagem
async function updateContactFromMessage(messageData, userId, sock = null) {
  try {
    const phoneNumber = messageData.phone;
    const chatId = messageData.chat_id;
    const connectionId = messageData.connection_id;
    
    if (!phoneNumber || !chatId || !connectionId) {
      console.log('‚ö†Ô∏è Dados insuficientes para atualizar contato:', { phoneNumber, chatId, connectionId });
      return;
    }

    // Buscar nome real do contato se dispon√≠vel
    let realContactName = messageData.wpp_name;
    if (sock) {
      const foundName = await getRealContactName(chatId, sock, messageData.wpp_name);
      if (foundName) {
        realContactName = foundName;
        messageData.wpp_name = foundName; // Atualizar tamb√©m no messageData
        console.log('‚úÖ Nome do contato atualizado para:', foundName);
      }
    }

    // Buscar contato existente
    const { data: existingContact, error: checkError } = await supabaseAdmin
      .from('contacts')
      .select('id')
      .eq('owner_id', userId)
      .or(`phone.eq.${phoneNumber},whatsapp_jid.eq.${chatId}`)
      .maybeSingle();

    if (existingContact) {
      console.log('üîÑ Atualizando contato existente:', existingContact.id);
      
      // Atualizar dados do WhatsApp - name_wpp deve ser igual a wpp_name
      const updateData = {
        name_wpp: messageData.wpp_name, // Usar o mesmo valor de wpp_name
        whatsapp_name: messageData.wpp_name,
        whatsapp_jid: chatId,
        whatsapp_connection_id: connectionId,
        whatsapp_last_message_at: new Date().toISOString(),
        whatsapp_last_message_content: messageData.conteudo,
        whatsapp_last_message_type: messageData.message_type,
        last_contact_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      };

      // Incrementar contador de mensagens
      const { error: updateError } = await supabaseAdmin
        .from('contacts')
        .update(updateData)
        .eq('id', existingContact.id);

      if (updateError) {
        console.error('‚ùå Erro ao atualizar contato:', updateError);
      } else {
        console.log('‚úÖ Contato atualizado com sucesso');
      }
    }
  } catch (error) {
    console.error('‚ùå Erro na fun√ß√£o updateContactFromMessage:', error);
  }
}

// Fun√ß√£o unificada para processar m√≠dia recebida
async function processIncomingMediaMessage(message, connectionId, userId) {
  try {
    console.log('üìé [UNIFIED-MEDIA] Processando m√≠dia recebida...');
    
    // Obter sock da conex√£o ativa
    const connection = activeConnections.get(connectionId);
    if (!connection) {
      console.error('‚ùå [UNIFIED-MEDIA] Conex√£o n√£o encontrada para:', connectionId);
      console.error('‚ùå [UNIFIED-MEDIA] Conex√µes ativas:', Array.from(activeConnections.keys()));
      return null;
    }
    
    const sock = connection.sock;
    if (!sock) {
      console.error('‚ùå [UNIFIED-MEDIA] Socket n√£o dispon√≠vel para processar m√≠dia');
      return null;
    }
    
    console.log('‚úÖ [UNIFIED-MEDIA] Sock encontrado para conex√£o:', connectionId);
    
    // 1. Baixar m√≠dia do WhatsApp primeiro
    const buffer = await downloadMediaMessage(
      message,
      'buffer',
      {},
      {
        logger: console,
        reuploadRequest: sock.updateMediaMessage
      }
    );
    
    if (!buffer || buffer.length === 0) {
      console.error('‚ùå [UNIFIED-MEDIA] Falha ao baixar buffer de m√≠dia');
      return null;
    }
    
    console.log(`üìé [UNIFIED-MEDIA] M√≠dia baixada: ${buffer.length} bytes`);
    
    // 2. Determinar tipo de m√≠dia e mimetype
    const mediaInfo = extractMediaInfo(message);
    
    // 3. Upload para Supabase Storage imediatamente
    const fileName = `media_${Date.now()}_${Math.random().toString(36).substr(2, 9)}.${getFileExtension(mediaInfo.mimetype)}`;
    
    const { error: uploadError } = await supabaseAdmin.storage
      .from('whatsapp')
      .upload(fileName, buffer, {
        contentType: mediaInfo.mimetype,
        upsert: false
      });
    
    if (uploadError) {
      console.error('‚ùå [UNIFIED-MEDIA] Falha no upload:', uploadError);
      return null;
    }
    
    console.log('‚úÖ [UNIFIED-MEDIA] M√≠dia salva no Supabase:', fileName);
    
    // 4. Criar URL assinada
    const { data: signedUrl } = await supabaseAdmin.storage
      .from('whatsapp')
      .createSignedUrl(fileName, 60 * 60 * 24 * 30); // 30 dias
    
    if (!signedUrl) {
      console.error('‚ùå [UNIFIED-MEDIA] Falha ao criar URL assinada');
      return null;
    }
    
    console.log('‚úÖ [UNIFIED-MEDIA] URL p√∫blica criada');
    
    return {
      url: signedUrl.signedUrl,
      mimetype: mediaInfo.mimetype,
      size: buffer.length,
      fileName: fileName
    };
    
  } catch (error) {
    console.error('‚ùå [UNIFIED-MEDIA] Falha no processamento de m√≠dia:', error);
    return null;
  }
}

// Fun√ß√£o auxiliar para extrair informa√ß√µes de m√≠dia
function extractMediaInfo(message) {
  let mimetype = 'application/octet-stream';
  let mediaType = 'unknown';
  
  if (message.message?.imageMessage) {
    mimetype = message.message.imageMessage.mimetype || 'image/jpeg';
    mediaType = 'image';
  } else if (message.message?.videoMessage) {
    mimetype = message.message.videoMessage.mimetype || 'video/mp4';
    mediaType = 'video';
  } else if (message.message?.audioMessage) {
    mimetype = message.message.audioMessage.mimetype || 'audio/ogg';
    mediaType = 'audio';
  } else if (message.message?.stickerMessage) {
    mimetype = message.message.stickerMessage.mimetype || 'image/webp';
    mediaType = 'sticker';
  } else if (message.message?.documentMessage) {
    mimetype = message.message.documentMessage.mimetype || 'application/octet-stream';
    mediaType = 'document';
  }
  
  return { mimetype, mediaType };
}

// Fun√ß√£o auxiliar para obter extens√£o de arquivo
function getFileExtension(mimetype) {
  // Limpar mimetype removendo codecs e par√¢metros extras
  const cleanMimetype = mimetype.split(';')[0].trim();
  
  const extensions = {
    'image/jpeg': 'jpg',
    'image/jpg': 'jpg',
    'image/png': 'png',
    'image/gif': 'gif',
    'image/webp': 'webp',
    'video/mp4': 'mp4',
    'video/quicktime': 'mov',
    'video/avi': 'avi',
    'audio/ogg': 'ogg',
    'audio/mpeg': 'mp3',
    'audio/wav': 'wav',
    'audio/mp4': 'm4a',
    'audio/webm': 'webm',
    'application/pdf': 'pdf',
    'application/msword': 'doc',
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document': 'docx',
    'text/plain': 'txt',
    'application/vnd.ms-excel': 'xls',
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': 'xlsx'
  };
  
  return extensions[cleanMimetype] || 'bin';
}

// Fun√ß√£o para verificar se mensagem tem conte√∫do de m√≠dia
function hasMediaContent(message) {
  return !!(message.message?.imageMessage || 
            message.message?.videoMessage || 
            message.message?.audioMessage || 
            message.message?.stickerMessage || 
            message.message?.documentMessage);
}

// Fun√ß√£o para buscar nome real do contato no WhatsApp
async function getRealContactName(chatId, sock, pushName = null) {
  if (!sock) {
    console.log('‚ÑπÔ∏è Socket n√£o dispon√≠vel para buscar nome do contato');
    return pushName || null;
  }

  try {
    console.log('üîç Buscando nome real do contato:', chatId);
    
    let realName = null;
    
    // M√©todo 1: Buscar business profile (para contas business)
    try {
      const businessProfile = await sock.getBusinessProfile(chatId);
      if (businessProfile && businessProfile.business_name) {
        realName = businessProfile.business_name;
        console.log('‚úÖ Nome real encontrado via business profile:', realName);
        return realName;
      }
    } catch (businessError) {
      console.log('‚ÑπÔ∏è Business profile n√£o dispon√≠vel:', businessError.message);
    }
    
    // M√©todo 2: Buscar no store de contatos (mais r√°pido)
    try {
      if (sock.store?.contacts?.[chatId]?.name) {
        realName = sock.store.contacts[chatId].name;
        console.log('‚úÖ Nome real encontrado no store:', realName);
        return realName;
      }
    } catch (storeError) {
      console.log('‚ÑπÔ∏è Store de contatos n√£o dispon√≠vel:', storeError.message);
    }
    
    // M√©todo 3: Usar getContact se dispon√≠vel
    try {
      if (typeof sock.getContact === 'function') {
        const contact = await sock.getContact(chatId);
        if (contact && contact.name) {
          realName = contact.name;
          console.log('‚úÖ Nome real encontrado via getContact:', realName);
          return realName;
        }
      }
    } catch (contactError) {
      console.log('‚ÑπÔ∏è getContact n√£o dispon√≠vel:', contactError.message);
    }
    
    // M√©todo 4: Buscar informa√ß√µes do chat usando fetchChats
    try {
      if (typeof sock.fetchChats === 'function') {
        const chatInfo = await sock.fetchChats({ limit: 100 });
        if (chatInfo && Array.isArray(chatInfo)) {
          const foundChat = chatInfo.find(c => c.id === chatId);
          if (foundChat && foundChat.subject && foundChat.subject.trim()) {
            realName = foundChat.subject.trim();
            console.log('‚úÖ Nome real encontrado via fetchChats:', realName);
            return realName;
          }
        }
      }
    } catch (chatError) {
      console.log('‚ÑπÔ∏è fetchChats n√£o dispon√≠vel:', chatError.message);
    }
    
    // M√©todo 5: Para grupos, tentar buscar informa√ß√µes do grupo
    try {
      if (chatId.includes('@g.us') && typeof sock.groupMetadata === 'function') {
        const groupMetadata = await sock.groupMetadata(chatId);
        if (groupMetadata && groupMetadata.subject) {
          realName = groupMetadata.subject;
          console.log('‚úÖ Nome real encontrado via groupMetadata:', realName);
          return realName;
        }
      }
    } catch (groupError) {
      console.log('‚ÑπÔ∏è groupMetadata n√£o dispon√≠vel:', groupError.message);
    }
    
    // Fallback: usar pushName se dispon√≠vel
    if (pushName && pushName.trim()) {
      console.log('‚úÖ Usando pushName como fallback:', pushName);
      return pushName.trim();
    }
    
    console.log('‚ÑπÔ∏è Nenhum nome real encontrado para:', chatId);
    return null;
    
  } catch (error) {
    console.error('‚ùå Erro ao buscar nome real do contato:', error);
    return pushName || null;
  }
}

// Fun√ß√£o para criar contato automaticamente a partir de mensagem
async function createContactFromMessage(messageData, userId, sock = null) {
  try {
    const phoneNumber = messageData.phone;
    const chatId = messageData.chat_id;
    const connectionId = messageData.connection_id;
    
    if (!phoneNumber || !chatId || !connectionId) {
      console.log('‚ö†Ô∏è Dados insuficientes para criar contato:', { phoneNumber, chatId, connectionId });
      return;
    }

    // Usar o extrator completo de informa√ß√µes
    let contactInfo = null;
    if (sock) {
      console.log('üîç [CONTACT-EXTRACTOR] ===== INICIANDO EXTRA√á√ÉO COMPLETA DE INFORMA√á√ïES =====');
      console.log('üîç [CONTACT-EXTRACTOR] Chat ID:', chatId);
      console.log('üîç [CONTACT-EXTRACTOR] Socket dispon√≠vel:', !!sock);
      
      const extractor = new ContactInfoExtractor(sock);
      contactInfo = await extractor.extractFullContactInfo(chatId, messageData);
      
      console.log('üìä [CONTACT-EXTRACTOR] ===== INFORMA√á√ïES EXTRA√çDAS =====');
      console.log('üìä [CONTACT-EXTRACTOR] Nome:', contactInfo.name);
      console.log('üìä [CONTACT-EXTRACTOR] Phone:', contactInfo.phone);
      console.log('üìä [CONTACT-EXTRACTOR] √â grupo:', contactInfo.isGroup);
      console.log('üìä [CONTACT-EXTRACTOR] √â neg√≥cio:', contactInfo.isBusiness);
      console.log('üìä [CONTACT-EXTRACTOR] √â verificado:', contactInfo.isVerified);
      console.log('üìä [CONTACT-EXTRACTOR] Est√° online:', contactInfo.isOnline);
      console.log('üìä [CONTACT-EXTRACTOR] Foto de perfil:', !!contactInfo.profilePicture);
      console.log('üìä [CONTACT-EXTRACTOR] Status:', contactInfo.status);
      console.log('üìä [CONTACT-EXTRACTOR] √öltima vez visto:', contactInfo.lastSeen);
      
      if (contactInfo.isGroup) {
        console.log('üë• [GROUP-INFO] ===== INFORMA√á√ïES DO GRUPO =====');
        console.log('üë• [GROUP-INFO] Nome do grupo:', contactInfo.groupSubject);
        console.log('üë• [GROUP-INFO] Descri√ß√£o:', contactInfo.groupDescription);
        console.log('üë• [GROUP-INFO] Propriet√°rio:', contactInfo.groupOwner);
        console.log('üë• [GROUP-INFO] Administradores:', contactInfo.groupAdmins?.length || 0);
        console.log('üë• [GROUP-INFO] Participantes:', contactInfo.participants?.length || 0);
        console.log('üë• [GROUP-INFO] Data de cria√ß√£o:', contactInfo.groupCreated);
      }
      
      if (contactInfo.isBusiness) {
        console.log('üè¢ [BUSINESS-INFO] ===== INFORMA√á√ïES DE NEG√ìCIO =====');
        console.log('üè¢ [BUSINESS-INFO] Nome do neg√≥cio:', contactInfo.businessName);
        console.log('üè¢ [BUSINESS-INFO] Descri√ß√£o:', contactInfo.businessDescription);
        console.log('üè¢ [BUSINESS-INFO] Categoria:', contactInfo.businessCategory);
        console.log('üè¢ [BUSINESS-INFO] Email:', contactInfo.businessEmail);
        console.log('üè¢ [BUSINESS-INFO] Website:', contactInfo.businessWebsite);
        console.log('üè¢ [BUSINESS-INFO] Endere√ßo:', contactInfo.businessAddress);
        console.log('üè¢ [BUSINESS-INFO] Verificado:', contactInfo.isVerified);
      }
      
      // Atualizar messageData com as informa√ß√µes encontradas
      if (contactInfo.name) {
        messageData.wpp_name = contactInfo.name;
        console.log('‚úÖ [FULL-INFO] Nome completo encontrado:', contactInfo.name);
      }
      
      // Adicionar informa√ß√µes de perfil √† messageData
      if (contactInfo.isGroup) {
        messageData.whatsapp_is_group = true;
        messageData.whatsapp_group_subject = contactInfo.groupSubject;
        messageData.whatsapp_group_description = contactInfo.groupDescription;
        messageData.whatsapp_group_owner = contactInfo.groupOwner;
        messageData.whatsapp_group_admins = contactInfo.groupAdmins;
        messageData.whatsapp_group_participants = contactInfo.participants;
        messageData.whatsapp_group_created = contactInfo.groupCreated;
        messageData.whatsapp_group_settings = contactInfo.groupSettings;
      } else {
        messageData.whatsapp_is_group = false;
        messageData.whatsapp_business_name = contactInfo.businessName;
        messageData.whatsapp_business_description = contactInfo.businessDescription;
        messageData.whatsapp_business_category = contactInfo.businessCategory;
        messageData.whatsapp_business_email = contactInfo.businessEmail;
        messageData.whatsapp_business_website = contactInfo.businessWebsite;
        messageData.whatsapp_business_address = contactInfo.businessAddress;
        messageData.whatsapp_verified = contactInfo.isVerified;
        messageData.whatsapp_online = contactInfo.isOnline;
        messageData.whatsapp_blocked = contactInfo.isBlocked;
        messageData.whatsapp_muted = contactInfo.isMuted;
        messageData.whatsapp_status = contactInfo.status;
        messageData.whatsapp_last_seen = contactInfo.lastSeen;
      }
      
      messageData.whatsapp_raw_data = contactInfo.rawData;
      messageData.whatsapp_presence = contactInfo.rawData.presence;
      
    } else {
      // Fallback para m√©todo antigo
      let realContactName = messageData.wpp_name;
      const foundName = await getRealContactName(chatId, sock, messageData.wpp_name);
      if (foundName) {
        realContactName = foundName;
        messageData.wpp_name = foundName;
        console.log('‚úÖ Nome do contato atualizado para:', foundName);
      }
    }

    // Verificar se contato j√° existe
    const { data: existingContact, error: checkError } = await supabaseAdmin
      .from('contacts')
      .select('id, whatsapp_jid, whatsapp_profile_picture, whatsapp_message_count, name_wpp, whatsapp_name')
      .eq('owner_id', userId)
      .or(`phone.eq.${phoneNumber},whatsapp_jid.eq.${chatId}`)
      .maybeSingle();

    if (existingContact) {
      console.log('‚úÖ Contato j√° existe, atualizando dados:', existingContact.id);
      
      // Usar a fun√ß√£o de atualiza√ß√£o
      await updateContactFromMessage(messageData, userId, sock);
      
      // Incrementar contador de mensagens separadamente
      const { error: countError } = await supabaseAdmin
        .from('contacts')
        .update({
          whatsapp_message_count: (existingContact.whatsapp_message_count || 0) + 1
        })
        .eq('id', existingContact.id);

      if (countError) {
        console.error('‚ùå Erro ao incrementar contador de mensagens:', countError);
      } else {
        console.log('‚úÖ Contador de mensagens incrementado');
      }
        
        // Buscar e atualizar foto de perfil se n√£o existir
        if (!existingContact.whatsapp_profile_picture && sock) {
          try {
            console.log('üì∏ Buscando foto de perfil para contato existente:', chatId);
            // Usar m√©todo correto do Baileys para obter foto de perfil
            const profilePictureUrl = await sock.profilePictureUrl(chatId, 'image');
            console.log('üì∏ Resultado da busca para contato existente:', profilePictureUrl);
            
            if (profilePictureUrl) {
              console.log('üì∏ Foto de perfil encontrada para contato existente:', profilePictureUrl);
              
              // Atualizar contato com a foto de perfil
              const { error: picUpdateError } = await supabaseAdmin
                .from('contacts')
                .update({ 
                  whatsapp_profile_picture: profilePictureUrl,
                  updated_at: new Date().toISOString()
                })
                .eq('id', existingContact.id);
                
              if (picUpdateError) {
                console.error('‚ùå Erro ao salvar foto de perfil:', picUpdateError);
              } else {
                console.log('‚úÖ Foto de perfil salva para contato existente');
                // updateData j√° foi definido anteriormente na fun√ß√£o
              }
            } else {
              console.log('‚ÑπÔ∏è Nenhuma foto de perfil encontrada para contato existente:', chatId);
            }
          } catch (profileError) {
            console.error('‚ùå Erro ao buscar foto de perfil para contato existente:', profileError);
            console.error('‚ùå Detalhes do erro:', profileError.message);
          }
        } else {
          console.log('‚ÑπÔ∏è Contato j√° possui foto de perfil:', existingContact.whatsapp_profile_picture);
        }
        
        // Emitir evento de atualiza√ß√£o
        io.emit('contact:updated', {
          contact: { 
            ...existingContact, 
            name_wpp: messageData.wpp_name,
            whatsapp_name: messageData.wpp_name,
            whatsapp_jid: chatId,
            whatsapp_connection_id: connectionId,
            whatsapp_last_message_at: new Date().toISOString()
          },
          message: 'Contato atualizado com dados do WhatsApp'
        });
        
        return;
      }

    if (checkError && checkError.code !== 'PGRST116') {
      console.error('‚ùå Erro ao verificar contato existente:', checkError);
      return;
    }

    // Criar novo contato com dados completos do WhatsApp
    let contactData;
    
    if (contactInfo) {
      // Usar informa√ß√µes completas do extrator
      contactData = await new ContactInfoExtractor(sock).saveContactInfoToDatabase(contactInfo, userId);
      if (!contactData) {
        // Fallback se houver erro - name_wpp deve ser igual a wpp_name
        contactData = {
          owner_id: userId,
          name: messageData.wpp_name || `Contato ${phoneNumber}`,
          phone: phoneNumber,
          name_wpp: messageData.wpp_name, // Usar o mesmo valor de wpp_name
          whatsapp_jid: chatId,
          whatsapp_name: messageData.wpp_name,
          whatsapp_connection_id: connectionId,
          whatsapp_registered_at: new Date().toISOString(),
          whatsapp_message_count: 1,
          whatsapp_last_message_at: new Date().toISOString(),
          whatsapp_last_message_content: messageData.conteudo,
          whatsapp_last_message_type: messageData.message_type,
          whatsapp_opted: true,
          ai_enabled: false,
          status: 'active',
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString(),
          last_contact_at: new Date().toISOString()
        };
      }
    } else {
      // Fallback para m√©todo antigo - name_wpp deve ser igual a wpp_name
      contactData = {
        owner_id: userId,
        name: messageData.wpp_name || `Contato ${phoneNumber}`,
        phone: phoneNumber,
        name_wpp: messageData.wpp_name, // Usar o mesmo valor de wpp_name
        whatsapp_jid: chatId,
        whatsapp_name: messageData.wpp_name,
        whatsapp_connection_id: connectionId,
        whatsapp_registered_at: new Date().toISOString(),
        whatsapp_message_count: 1,
        whatsapp_last_message_at: new Date().toISOString(),
        whatsapp_last_message_content: messageData.conteudo,
        whatsapp_last_message_type: messageData.message_type,
        whatsapp_opted: true,
        ai_enabled: false,
        status: 'active',
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
        last_contact_at: new Date().toISOString()
      };
    }

    // Inserir novo contato
    const { data: newContact, error: insertError } = await supabaseAdmin
      .from('contacts')
      .insert(contactData)
      .select()
      .single();

    if (insertError) {
      console.error('‚ùå Erro ao criar contato:', insertError);
      return;
    }

    console.log('‚úÖ Contato criado com dados do WhatsApp:', newContact.id);
    
    // Buscar e salvar foto de perfil do WhatsApp
    try {
      console.log('üì∏ Buscando foto de perfil para:', chatId);
      
      // Tentar m√∫ltiplas formas de obter a foto de perfil
      let profilePictureUrl = null;
      
      // M√©todo 1: Usar profilePictureUrl (alta resolu√ß√£o)
      if (sock) {
        try {
          profilePictureUrl = await sock.profilePictureUrl(chatId, 'image');
          console.log('üì∏ Tentativa 1 - profilePictureUrl (alta res):', profilePictureUrl);
        } catch (err) {
          console.log('‚ö†Ô∏è M√©todo 1 (alta res) falhou:', err.message);
          
          // Tentar com baixa resolu√ß√£o
          try {
            profilePictureUrl = await sock.profilePictureUrl(chatId);
            console.log('üì∏ Tentativa 1b - profilePictureUrl (baixa res):', profilePictureUrl);
          } catch (err2) {
            console.log('‚ö†Ô∏è M√©todo 1b (baixa res) falhou:', err2.message);
          }
        }
      } else {
        console.log('‚ö†Ô∏è Sock n√£o dispon√≠vel para buscar foto de perfil');
      }
      
      // Tentar buscar status do contato se sock estiver dispon√≠vel
      if (sock && !profilePictureUrl) {
        try {
          console.log('üì± Buscando status do contato:', chatId);
          const status = await sock.fetchStatus(chatId);
          console.log('üì± Status do contato:', status);
          
          // Se temos status, podemos usar como fallback para nome
          if (status && status.status) {
            console.log('üì± Status encontrado:', status.status);
          }
        } catch (statusError) {
          console.log('‚ö†Ô∏è Erro ao buscar status:', statusError.message);
        }
      }
      
      // M√©todo 2: Usar getProfilePicture
      if (!profilePictureUrl) {
        try {
          profilePictureUrl = await sock.getProfilePicture(chatId);
          console.log('üì∏ Tentativa 2 - getProfilePicture:', profilePictureUrl);
        } catch (err) {
          console.log('‚ö†Ô∏è M√©todo 2 falhou:', err.message);
        }
      }
      
      // M√©todo 3: Buscar no store de contatos
      if (!profilePictureUrl && sock.store?.contacts?.[chatId]?.imgUrl) {
        profilePictureUrl = sock.store.contacts[chatId].imgUrl;
        console.log('üì∏ Tentativa 3 - store contacts:', profilePictureUrl);
      }
      
      if (profilePictureUrl) {
        console.log('üì∏ Foto de perfil encontrada:', profilePictureUrl);
        
        // Atualizar contato com a foto de perfil
        const { error: updateError } = await supabaseAdmin
          .from('contacts')
          .update({ 
            whatsapp_profile_picture: profilePictureUrl,
            updated_at: new Date().toISOString()
          })
          .eq('id', newContact.id);
          
        if (updateError) {
          console.error('‚ùå Erro ao salvar foto de perfil:', updateError);
        } else {
          console.log('‚úÖ Foto de perfil salva com sucesso');
          // Atualizar o objeto do contato para emitir
          newContact.whatsapp_profile_picture = profilePictureUrl;
        }
      } else {
        console.log('‚ÑπÔ∏è Nenhuma foto de perfil encontrada para', chatId);
      }
    } catch (profileError) {
      console.error('‚ùå Erro ao buscar foto de perfil:', profileError);
      console.error('‚ùå Detalhes do erro:', profileError.message);
    }
    
    // Emitir evento para o frontend
    io.emit('contact:created', {
      contact: newContact,
      message: 'Novo contato criado automaticamente do WhatsApp'
    });

    return newContact;

  } catch (error) {
    console.error('‚ùå Erro na fun√ß√£o createContactFromMessage:', error);
  }
}

// Media helper functions
function unwrapForDownload(m) {
  if (!m) return {};
  if (m.ephemeralMessage?.message) m = m.ephemeralMessage.message;
  if (m.viewOnceMessageV2?.message) m = m.viewOnceMessageV2.message;
  if (m.viewOnceMessage?.message)  m = m.viewOnceMessage.message;
  if (m.documentWithCaptionMessage?.message) m = m.documentWithCaptionMessage.message;
  return m ?? {};
}

function detectMime(msg) {
  const m = unwrapForDownload(msg.message);
  return (
    m?.imageMessage?.mimetype ||
    m?.videoMessage?.mimetype ||
    m?.audioMessage?.mimetype ||
    m?.documentMessage?.mimetype ||
    m?.stickerMessage?.mimetype ||
    'application/octet-stream'
  );
}

async function fetchAndUploadMedia({ supabase, bucket='whatsapp', keyPrefix, msg, logger=console, sock }) {
  if (!downloadMediaMessage) throw new Error('downloadMediaMessage not available yet');
  const unwrapped = { ...msg, message: unwrapForDownload(msg.message) };

  try {
    // Usar a abordagem recomendada do Baileys com reuploadRequest
    const buffer = await downloadMediaMessage(
      unwrapped, 
      'buffer', 
      {}, 
      { 
        logger,
        // Passar sock.updateMediaMessage para permitir reupload de m√≠dia deletada
        reuploadRequest: sock?.updateMediaMessage
      }
    );
    
    const mime   = detectMime(msg);
    const ext    = (mime.split('/')[1] || 'bin').split(';')[0];
    const filePath = `${keyPrefix}.${ext}`;

    const { error: upErr } = await supabase.storage.from(bucket)
      .upload(filePath, buffer, { contentType: mime, upsert: true });
    if (upErr) throw upErr;

    const { data: signed, error: urlErr } = await supabase.storage.from(bucket)
      .createSignedUrl(filePath, 60 * 60 * 24 * 7); // 7d
    if (urlErr) throw urlErr;

    return { url: signed.signedUrl, mime, size: buffer.length, path: filePath };
  } catch (error) {
    logger.error('‚ùå Erro ao baixar/enviar m√≠dia:', error);
    throw error;
  }
}

function isMediaTipo(tipo) {
  return ['IMAGEM','VIDEO','AUDIO','STICKER','ARQUIVO'].includes(String(tipo).toUpperCase());
}

// Preview helper for conversation list
function previewLabel(message_type, conteudo, duration_ms) {
  const t = String(message_type || '').toUpperCase();
  switch (t) {
    case 'TEXTO':        return (conteudo || '').slice(0, 120);
    case 'IMAGEM':       return `üñºÔ∏è Foto${conteudo ? ': ' + conteudo.slice(0, 80) : ''}`;
    case 'VIDEO':        return `üé¨ V√≠deo${conteudo ? ': ' + conteudo.slice(0, 80) : ''}`;
    case 'AUDIO':        return `üéß √Åudio${duration_ms ? ' (' + Math.round(duration_ms/1000) + 's)' : ''}`;
    case 'STICKER':      return 'üíü Figurinha';
    case 'ARQUIVO':      return `üìé Arquivo${conteudo ? ': ' + conteudo.slice(0, 80) : ''}`;
    case 'LOCALIZACAO':  return 'üìç Localiza√ß√£o';
    case 'RESPOSTA_BOTAO': return `üîò ${conteudo || 'Resposta de Bot√£o'}`;
    case 'RESPOSTA_LISTA': return `üìã ${conteudo || 'Resposta de Lista'}`;
    case 'RESPOSTA_TEMPLATE': return `üìÑ ${conteudo || 'Resposta de Template'}`;
    default:             return conteudo ? conteudo.slice(0, 120) : '[Mensagem]';
  }
}

// Fun√ß√£o para verificar limites de sess√µes por owner_id
async function checkSessionLimits(ownerId) {
  try {
    const { data: connectedSessions, error } = await supabase
      .from('whatsapp_sessions')
      .select('connection_id')
      .eq('owner_id', ownerId)
      .eq('status', 'connected');
    
    if (error) {
      console.error('‚ùå Erro ao verificar limites de sess√µes:', error);
      return { canCreate: false, reason: 'ERROR_CHECKING_LIMITS' };
    }
    
    const connectedCount = connectedSessions?.length || 0;
    const maxSessions = 5;
    
    if (connectedCount >= maxSessions) {
      console.log(`‚ö†Ô∏è Limite de ${maxSessions} sess√µes conectadas atingido para owner_id: ${ownerId}`);
      return { canCreate: false, reason: 'MAX_SESSIONS_REACHED', currentCount: connectedCount };
    }
    
    return { canCreate: true, currentCount: connectedCount };
  } catch (error) {
    console.error('‚ùå Erro ao verificar limites:', error);
    return { canCreate: false, reason: 'ERROR' };
  }
}

// Fun√ß√£o para salvar/atualizar sess√£o no Supabase
async function saveSessionToSupabase(connectionId, sessionData, userId) {
  try {
    // OBRIGAT√ìRIO: userId deve ser fornecido e n√£o pode ser o ID padr√£o
    if (!userId || userId === '00000000-0000-0000-0000-000000000000') {
      throw new Error('userId √© obrigat√≥rio e deve ser um ID v√°lido da tabela profiles');
    }
    // Verificar se connection_id j√° existe (regra: 1 max por connection_id)
    const { data: existingSession, error: checkError } = await supabase
      .from('whatsapp_sessions')
      .select('*')
      .eq('connection_id', connectionId)
      .single();
    
    if (checkError && checkError.code !== 'PGRST116') {
      console.error('‚ùå Erro ao verificar sess√£o existente:', checkError);
      return;
    }
    
    // Se a sess√£o existe, atualizar em vez de criar nova
    if (existingSession) {
      console.log(`üîÑ Atualizando sess√£o existente: ${connectionId}`);
      
      const updateData = {
        session_name: sessionData.name || existingSession.session_name,
        status: sessionData.status,
        qr_code: sessionData.qr_code || existingSession.qr_code,
        phone: sessionData.phone || existingSession.phone,
        whatsapp_info: sessionData.whatsapp_info || existingSession.whatsapp_info,
        connected_at: sessionData.status === 'connected' ? new Date().toISOString() : existingSession.connected_at,
        disconnected_at: sessionData.status === 'disconnected' ? new Date().toISOString() : existingSession.disconnected_at,
        updated_at: new Date().toISOString()
      };
      
      const { error: updateError } = await supabase
        .from('whatsapp_sessions')
        .update(updateData)
        .eq('connection_id', connectionId);
      
      if (updateError) {
        console.error('‚ùå Erro ao atualizar sess√£o:', updateError);
      } else {
        console.log(`‚úÖ Sess√£o atualizada para usu√°rio ${userId}: ${connectionId}`);
      }
      return;
    }
    
    // Verificar limites antes de criar nova sess√£o (regra: 5 max por owner_id)
    if (sessionData.status === 'connected') {
      const limitCheck = await checkSessionLimits(userId);
      if (!limitCheck.canCreate) {
        console.log(`‚ùå N√£o √© poss√≠vel criar sess√£o conectada: ${limitCheck.reason}`);
        return;
      }
    }
    
    // Build payload with user owner_id
    const payload = {
      owner_id: userId, // User ID espec√≠fico
      session_name: sessionData.name || `Conex√£o ${connectionId}`,
      status: sessionData.status,
      connection_id: connectionId,
      qr_code: sessionData.qr_code || null,
      phone: sessionData.phone || null,
      whatsapp_info: sessionData.whatsapp_info || null,
      connected_at: sessionData.status === 'connected' ? new Date().toISOString() : null,
      disconnected_at: sessionData.status === 'disconnected' ? new Date().toISOString() : null,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    };
    console.log('üîç saveSessionToSupabase - Dados recebidos:', { connectionId, sessionData, userId });
    console.log(`üì§ Enviando payload para Supabase:`, JSON.stringify(payload, null, 2));
    
    const { error } = await supabase
      .from('whatsapp_sessions')
      .insert(payload);
    
    if (error) {
      console.error('‚ùå Erro ao salvar sess√£o no Supabase:', error);
    } else {
      console.log(`‚úÖ Sess√£o salva para usu√°rio ${userId}: ${connectionId}`);
    }
  } catch (error) {
    console.error('Erro ao salvar sess√£o:', error);
  }
}

// Fun√ß√£o para remover sess√£o do Supabase
async function removeSessionFromSupabase(connectionId) {
  try {
    const { error } = await supabase
      .from('whatsapp_sessions')
      .delete()
      .eq('connection_id', connectionId);
    
    if (error) {
      console.error('Erro ao remover sess√£o do Supabase:', error);
    }
  } catch (error) {
    console.error('Erro ao remover sess√£o:', error);
  }
}

// Fun√ß√£o para atualizar status de conex√£o com timestamps corretos
async function updateConnectionStatus(connectionId, status, additionalData = {}, userId = null) {
  try {
    // OBRIGAT√ìRIO: userId deve ser fornecido e n√£o pode ser o ID padr√£o
    if (!userId || userId === '00000000-0000-0000-0000-000000000000') {
      console.error('‚ùå userId √© obrigat√≥rio e deve ser um ID v√°lido da tabela profiles');
      return;
    }
    // Verificar limites antes de conectar (regra: 5 max por owner_id)
    if (status === 'connected' && userId) {
      const limitCheck = await checkSessionLimits(userId);
      if (!limitCheck.canCreate) {
        console.log(`‚ùå N√£o √© poss√≠vel conectar: limite de 5 sess√µes atingido para owner_id: ${userId}`);
        return;
      }
    }

    const updateData = {
      status: status,
      updated_at: new Date().toISOString(),
      ...additionalData
    };

    // Preservar session_name se n√£o estiver sendo atualizado explicitamente
    if (!additionalData.session_name) {
      // Buscar o session_name atual para preserv√°-lo
      const { data: currentSession } = await supabase
        .from('whatsapp_sessions')
        .select('session_name')
        .eq('connection_id', connectionId)
        .single();
      
      if (currentSession?.session_name) {
        updateData.session_name = currentSession.session_name;
      }
    }

    // Adicionar timestamps baseado no status
    if (status === 'connected') {
      updateData.connected_at = new Date().toISOString();
      updateData.disconnected_at = null; // Limpar disconnected_at quando conectar
    } else if (status === 'disconnected') {
      updateData.disconnected_at = new Date().toISOString();
      // N√£o alterar connected_at - manter o valor original
    }

    let query = supabase
      .from('whatsapp_sessions')
      .update(updateData)
      .eq('connection_id', connectionId);
    
    // Se userId for fornecido, filtrar tamb√©m por owner_id
    if (userId) {
      query = query.eq('owner_id', userId);
    }
    
    const { error } = await query;
    
    if (error) {
      console.error('‚ùå Erro ao atualizar status da conex√£o:', error);
    } else {
      console.log(`‚úÖ Status da conex√£o ${connectionId} atualizado para: ${status}`);
    }
  } catch (error) {
    console.error('‚ùå Erro ao atualizar status da conex√£o:', error);
  }
}

// Fun√ß√£o para carregar sess√µes existentes do Supabase
async function loadExistingSessions() {
  try {
    // N√ÉO carregar sess√µes com owner_id padr√£o - apenas sess√µes v√°lidas
    const { data: sessions, error } = await supabase
      .from('whatsapp_sessions')
      .select('*')
      .eq('status', 'connected')
      .not('connection_id', 'is', null)
      .neq('owner_id', '00000000-0000-0000-0000-000000000000'); // Excluir owner_id padr√£o
    
    if (error) {
      console.error('Erro ao carregar sess√µes:', error);
      return;
    }
    
    console.log(`üìã Carregadas ${sessions?.length || 0} sess√µes existentes do Supabase (excluindo owner_id padr√£o)`);
    return sessions || [];
  } catch (error) {
    console.error('Erro ao carregar sess√µes existentes:', error);
    return [];
  }
}

// Fun√ß√£o para gerar QR Code real do WhatsApp
async function createWhatsAppConnection(connectionId, userId = null, connectionData = {}) {
  try {
    console.log('üîç createWhatsAppConnection - Dados recebidos:', { connectionId, userId, connectionData });
    
    // Buscar usu√°rio ativo se n√£o fornecido
    if (!userId) {
      const activeUser = await getActiveUser();
      if (!activeUser) {
        throw new Error('Nenhum usu√°rio ativo encontrado (session_status = ONLINE)');
      }
      userId = activeUser.id;
    }
    
    // Verificar se a conex√£o j√° existe para evitar duplicatas
    if (activeConnections.has(connectionId)) {
      console.log(`‚ö†Ô∏è Conex√£o ${connectionId} j√° existe, ignorando cria√ß√£o duplicada`);
      return activeConnections.get(connectionId).sock;
    }
    
    console.log(`üîó Criando conex√£o WhatsApp para: ${connectionId} com owner_id: ${userId}`);
    
    // Importar Baileys dinamicamente
    if (!makeWASocket) {
      try {
        const baileys = await import('baileys');
        makeWASocket = baileys.default;
        DisconnectReason = baileys.DisconnectReason;
        useMultiFileAuthState = baileys.useMultiFileAuthState;
        downloadMediaMessage = baileys.downloadMediaMessage;
        jidNormalizedUser = baileys.jidNormalizedUser;
        console.log('‚úÖ Baileys importado com sucesso');
      } catch (error) {
        console.error('‚ùå Erro ao importar Baileys:', error);
        throw new Error('Falha ao importar Baileys: ' + error.message);
      }
    }
    
    const { Boom } = await import('@hapi/boom');
    
    // Diret√≥rio para salvar dados de autentica√ß√£o
    const authDir = path.join(__dirname, 'auth_info', connectionId);
    if (!fs.existsSync(authDir)) {
      fs.mkdirSync(authDir, { recursive: true });
    }
    
    // Configurar estado de autentica√ß√£o
    const { state, saveCreds } = await useMultiFileAuthState(authDir);
    
    // Criar socket WhatsApp
    const sock = makeWASocket({
      auth: state,
      printQRInTerminal: true,
      logger: require('pino')({ level: 'silent' }),
      browser: ['WhatsApp Web', 'Chrome', '1.0.0'],
      generateHighQualityLinkPreview: true,
      getMessage: async (key) => {
        return {
          conversation: 'test',
          message: {
            conversation: 'test'
          }
        };
      }
    });
    
    // Evento de conex√£o
    sock.ev.on('connection.update', async (update) => {
      const { connection, lastDisconnect, qr } = update;
      
      if (qr) {
        console.log(`üì± QR Code gerado para ${connectionId}`);
        console.log(`QR Code length: ${qr.length}`);
        console.log(`QR Code first 10 chars: ${qr.substring(0, 10)}`);
        console.log(`QR Code last 10 chars: ${qr.substring(qr.length - 10)}`);
        
        // Salvar QR code no Supabase (manter como disconnected at√© conectar)
        await updateConnectionStatus(connectionId, 'disconnected', {
          qr_code: qr
        }, userId);
        
        // Emitir QR code via Socket.IO
        io.emit('qrCode', { 
          connectionId: connectionId, 
          qrCode: qr 
        });
      }
      
      if (connection === 'close') {
        const shouldReconnect = (lastDisconnect?.error instanceof Boom)?.output?.statusCode !== DisconnectReason.loggedOut;
        console.log(`üîå Conex√£o fechada para ${connectionId}, reconectar: ${shouldReconnect}`);
        
        if (shouldReconnect) {
          // Verificar se n√£o excedeu o limite de tentativas
          const attempts = reconnectionAttempts.get(connectionId) || 0;
          if (attempts < MAX_RECONNECTION_ATTEMPTS) {
            reconnectionAttempts.set(connectionId, attempts + 1);
            console.log(`üîÑ Tentativa de reconex√£o ${attempts + 1}/${MAX_RECONNECTION_ATTEMPTS} para ${connectionId}`);
            
            // Manter como desconectado e tentar reconectar
            await updateConnectionStatus(connectionId, 'disconnected', {}, userId);
            // Remover da mem√≥ria para evitar loops
            activeConnections.delete(connectionId);
            
            // Tentar reconectar ap√≥s um delay
            setTimeout(() => {
              createWhatsAppConnection(connectionId, userId);
            }, 5000); // 5 segundos de delay
          } else {
            console.log(`‚ùå Limite de tentativas de reconex√£o atingido para ${connectionId}`);
            reconnectionAttempts.delete(connectionId);
            activeConnections.delete(connectionId);
            await updateConnectionStatus(connectionId, 'disconnected', {}, userId);
            io.emit('connectionRemoved', { connectionId });
          }
        } else {
          // Marcar como desconectado no Supabase
          console.log(`üóëÔ∏è Marcando conex√£o como desconectada: ${connectionId}`);
          await updateConnectionStatus(connectionId, 'disconnected', {}, userId);
          
          // Remover da mem√≥ria
          activeConnections.delete(connectionId);
          
          // Emitir evento de remo√ß√£o para o frontend
          io.emit('connectionRemoved', { connectionId });
        }
      } else if (connection === 'open') {
        console.log(`‚úÖ Conectado ao WhatsApp: ${connectionId}`);
        // Limpar contador de tentativas de reconex√£o
        reconnectionAttempts.delete(connectionId);
        
        const connection = activeConnections.get(connectionId);
        if (connection) {
          connection.connectionState = 'connected';
          connection.isConnected = true;
          connection.qrCode = null;
          connection.updatedAt = new Date().toISOString();
        }
        
        // Obter informa√ß√µes do WhatsApp (incluindo n√∫mero do telefone)
        const whatsappInfo = sock.user;
        const phoneNumber = whatsappInfo?.id?.split(':')[0] || null;
        const whatsappId = whatsappInfo?.id || null; // ID completo com @s.whatsapp.net
        
        console.log(`üì± WhatsApp conectado - N√∫mero: ${phoneNumber}`);
        console.log(`üì± WhatsApp ID completo: ${whatsappId}`);
        
        // Verificar se j√° existe uma conex√£o ativa com o mesmo n√∫mero de telefone
        if (phoneNumber) {
          const { data: duplicateSessions, error: duplicateError } = await supabase
            .from('whatsapp_sessions')
            .select('*')
            .eq('owner_id', userId)
            .eq('phone', phoneNumber)
            .eq('status', 'connected')
            .neq('connection_id', connectionId);
          
          if (duplicateError) {
            console.error('Erro ao verificar duplicatas por n√∫mero:', duplicateError);
          } else if (duplicateSessions && duplicateSessions.length > 0) {
            console.log(`‚ö†Ô∏è N√∫mero ${phoneNumber} j√° est√° conectado em outra sess√£o`);
            
            // Desconectar a sess√£o anterior
            for (const duplicateSession of duplicateSessions) {
              await updateConnectionStatus(duplicateSession.connection_id, 'disconnected', {
                phone: phoneNumber,
                duplicate_reason: 'REPLACED_BY_NEW_CONNECTION'
              }, userId);
              
              // Remover da mem√≥ria se existir
              if (activeConnections.has(duplicateSession.connection_id)) {
                const oldConnection = activeConnections.get(duplicateSession.connection_id);
                if (oldConnection.sock) {
                  oldConnection.sock.logout();
                }
                activeConnections.delete(duplicateSession.connection_id);
              }
            }
            
            console.log(`üîÑ Substituindo conex√£o anterior pelo n√∫mero ${phoneNumber}`);
          }
        }
        
        // Salvar sess√£o conectada no Supabase com n√∫mero do telefone e WhatsApp ID
        await updateConnectionStatus(connectionId, 'connected', {
          qr_code: null, // Limpar QR code quando conectado
          phone: phoneNumber,
          whatsapp_id: whatsappId, // ID completo com @s.whatsapp.net
          whatsapp_info: whatsappInfo
        }, userId);
        
        // Emitir status de conex√£o
        io.emit('connectionUpdate', { 
          connectionId: connectionId, 
          update: { connection: 'open' } 
        });
      }
    });
    
    // Evento de credenciais
    sock.ev.on('creds.update', saveCreds);
    
    // Evento de mensagens
    sock.ev.on('messages.upsert', async (m) => {
      try {
        const messages = m.messages || [];
        console.log(`üì® ===== MENSAGENS RECEBIDAS =====`);
        console.log(`üì® Conex√£o: ${connectionId}`);
        console.log(`üì® Total de mensagens: ${messages.length}`);
        console.log(`üì® Timestamp: ${new Date().toISOString()}`);
        
        // Obter informa√ß√µes do WhatsApp conectado
        const whatsappInfo = sock.user;
        const connectionPhone = whatsappInfo?.id?.split(':')[0] || null;
        
        console.log(`üì± [CONNECTION-INFO] WhatsApp conectado:`, {
          id: whatsappInfo?.id,
          name: whatsappInfo?.name,
          phone: connectionPhone
        });
        
        for (let i = 0; i < messages.length; i++) {
          const message = messages[i];
          
          console.log(`\nüì® ===== MENSAGEM ${i + 1}/${messages.length} =====`);
          console.log(`üì® ID: ${message.key?.id}`);
          console.log(`üì® De: ${message.key?.remoteJid}`);
          console.log(`üì® Para: ${message.key?.participant}`);
          console.log(`üì® Enviada por n√≥s: ${message.key?.fromMe}`);
          console.log(`üì® Timestamp: ${message.messageTimestamp}`);
          console.log(`üì® Push Name: ${message.pushName || 'N/A'}`);
          console.log(`üì® Tipo: ${message.message?.conversation ? 'TEXTO' : Object.keys(message.message || {})[0] || 'DESCONHECIDO'}`);
          
          // Log do conte√∫do da mensagem
          if (message.message?.conversation) {
            console.log(`üìù [TEXTO] Conte√∫do: ${message.message.conversation.substring(0, 100)}${message.message.conversation.length > 100 ? '...' : ''}`);
          } else if (message.message?.imageMessage) {
            console.log(`üñºÔ∏è [IMAGEM] Caption: ${message.message.imageMessage.caption || 'Sem legenda'}`);
            console.log(`üñºÔ∏è [IMAGEM] MIME: ${message.message.imageMessage.mimetype}`);
            console.log(`üñºÔ∏è [IMAGEM] Tamanho: ${message.message.imageMessage.fileLength || 'N/A'} bytes`);
          } else if (message.message?.videoMessage) {
            console.log(`üé• [V√çDEO] Caption: ${message.message.videoMessage.caption || 'Sem legenda'}`);
            console.log(`üé• [V√çDEO] MIME: ${message.message.videoMessage.mimetype}`);
            console.log(`üé• [V√çDEO] Dura√ß√£o: ${message.message.videoMessage.seconds || 'N/A'} segundos`);
          } else if (message.message?.audioMessage) {
            console.log(`üéµ [√ÅUDIO] MIME: ${message.message.audioMessage.mimetype}`);
            console.log(`üéµ [√ÅUDIO] Dura√ß√£o: ${message.message.audioMessage.seconds || 'N/A'} segundos`);
          } else if (message.message?.documentMessage) {
            console.log(`üìÑ [DOCUMENTO] Nome: ${message.message.documentMessage.fileName || 'Sem nome'}`);
            console.log(`üìÑ [DOCUMENTO] MIME: ${message.message.documentMessage.mimetype}`);
            console.log(`üìÑ [DOCUMENTO] Tamanho: ${message.message.documentMessage.fileLength || 'N/A'} bytes`);
          }
          
          // Verificar se √© grupo
          const isGroup = message.key?.remoteJid?.includes('@g.us');
          console.log(`üë• [GRUPO] √â grupo: ${isGroup}`);
          if (isGroup) {
            console.log(`üë• [GRUPO] ID do grupo: ${message.key?.remoteJid}`);
            console.log(`üë• [GRUPO] Remetente no grupo: ${message.key?.participant}`);
          }
          
          // Ignorar mensagens de status e broadcast
          if (message.key?.remoteJid?.includes('status@broadcast') || 
              message.key?.remoteJid?.includes('@broadcast') ||
              message.key?.remoteJid?.includes('status@')) {
            console.log('‚ö†Ô∏è [IGNORAR] Mensagem de status/broadcast ignorada');
            continue;
          }
          
          // Para mensagens enviadas por n√≥s mesmos, verificar se j√° foi processada
          if (message.key?.fromMe === true) {
            console.log('üì§ Mensagem enviada por n√≥s mesmos:', message.key?.id);
            
            // Verificar se j√° existe no banco para evitar duplica√ß√£o
            const { data: existingMessage } = await supabaseAdmin
              .from('whatsapp_mensagens')
              .select('id')
              .eq('message_id', message.key.id)
              .eq('connection_id', connectionId)
              .single();
            
            if (existingMessage) {
              console.log('‚ö†Ô∏è Mensagem j√° existe no banco, ignorando:', message.key?.id);
              continue;
            }
            
            console.log('‚úÖ Processando mensagem enviada por n√≥s mesmos:', message.key?.id);
          }
          
          // Normalizar mensagem usando o message-normalizer
          console.log(`üîÑ [NORMALIZA√á√ÉO] Iniciando normaliza√ß√£o da mensagem...`);
          const messageData = mapToDbRow(message, null, connectionId, userId);
          
          console.log(`üìä [MESSAGE-DATA] Dados normalizados:`, {
            chat_id: messageData.chat_id,
            remetente: messageData.remetente,
            tipo: messageData.tipo,
            conteudo: messageData.conteudo?.substring(0, 50) + (messageData.conteudo?.length > 50 ? '...' : ''),
            media_url: messageData.media_url,
            media_tipo: messageData.media_tipo
          });
          
          // Adicionar informa√ß√µes da conex√£o
          messageData.connection_id = connectionId; // ID real da conex√£o
          messageData.connection_phone = connectionPhone;
          messageData.phone = messageData.chat_id ? messageData.chat_id.split('@')[0] : null;
          
          console.log(`üì± [CONNECTION-DATA] Dados da conex√£o:`, {
            connection_id: messageData.connection_id,
            connection_phone: messageData.connection_phone,
            phone: messageData.phone
          });
          
        // Processar m√≠dia ANTES de salvar mensagem
        if (hasMediaContent(message)) {
          console.log('üìé Processando m√≠dia antes de salvar mensagem...');
          
          // Verificar se j√° temos uma URL do Supabase (mensagem enviada por n√≥s)
          if (messageData.media_url && messageData.media_url.includes('supabase.co')) {
            console.log('‚úÖ M√≠dia j√° tem URL do Supabase, mantendo:', messageData.media_url);
          } else {
            // Processar m√≠dia recebida - SEMPRE normalizar para Supabase
            const mediaResult = await processIncomingMediaMessage(message, connectionId, userId);

            if (mediaResult) {
              messageData.media_url = mediaResult.url;
              messageData.media_mime = mediaResult.mimetype;
              messageData.media_type = extractMediaInfo(message).mediaType;
              console.log('‚úÖ M√≠dia processada e URLs definidas:', {
                url: mediaResult.url,
                mimetype: mediaResult.mimetype,
                mediaType: extractMediaInfo(message).mediaType
              });
            } else {
              console.log('‚ö†Ô∏è Falha no processamento de m√≠dia, salvando mensagem sem m√≠dia');
              // Garantir que n√£o salvemos media:hash
              messageData.media_url = null;
              messageData.media_mime = null;
              messageData.media_type = null;
            }
          }
        } else {
          // Para mensagens sem m√≠dia, garantir que n√£o tenhamos media:hash
          messageData.media_url = null;
          messageData.media_mime = null;
          messageData.media_type = null;
        }
          
          // Definir wpp_name e group_contact_name baseado no remetente
          if (messageData.remetente === 'ATENDENTE') {
            messageData.wpp_name = 'Atendente';
            messageData.group_contact_name = null;
          } else if (messageData.remetente === 'CLIENTE' && messageData.phone) {
            // Para grupos, usar pushName como group_contact_name
            if (messageData.chat_id && messageData.chat_id.includes('@g.us')) {
              messageData.group_contact_name = message.pushName || null;
              console.log('üë• [GROUP] Nome do contato no grupo:', messageData.group_contact_name);
            } else {
              messageData.group_contact_name = null;
            }
            try {
              // Obter sock da conex√£o ativa
              const connection = activeConnections.get(connectionId);
              const activeSock = connection?.sock;
              
              console.log('üîç [CONTACT-INFO] ===== INICIANDO CAPTURA DE INFORMA√á√ïES DO CONTATO =====');
              console.log('üîç [CONTACT-INFO] Chat ID:', messageData.chat_id);
              console.log('üîç [CONTACT-INFO] Phone:', messageData.phone);
              console.log('üîç [CONTACT-INFO] Push Name:', message.pushName);
              console.log('üîç [CONTACT-INFO] Socket dispon√≠vel:', !!activeSock);
              console.log('üîç [CONTACT-INFO] Store dispon√≠vel:', !!(activeSock?.store));
              console.log('üîç [CONTACT-INFO] √â grupo:', messageData.chat_id?.includes('@g.us'));
              
              if (activeSock) {
                // Usar a fun√ß√£o getRealContactName para buscar o nome
                const realContactName = await getRealContactName(messageData.chat_id, activeSock, message.pushName);
                
                // Verificar se √© um grupo
                const isGroup = messageData.chat_id?.includes('@g.us');
                
                if (isGroup) {
                  // Para grupos: wpp_name = nome do grupo, group_contact_name = pushName do remetente
                  if (realContactName && realContactName.trim()) {
                    messageData.wpp_name = realContactName.trim(); // Nome do grupo
                    console.log('‚úÖ [DEBUG-NAMES] Nome do grupo encontrado:', messageData.wpp_name);
                  } else {
                    messageData.wpp_name = `Grupo ${messageData.phone}`;
                    console.log('‚ö†Ô∏è [DEBUG-NAMES] Usando nome padr√£o para grupo:', messageData.wpp_name);
                  }
                  
                  // Definir group_contact_name com o pushName do remetente
                  if (message.pushName && message.pushName.trim()) {
                    messageData.group_contact_name = message.pushName.trim();
                    console.log('‚úÖ [DEBUG-NAMES] Nome do contato no grupo:', messageData.group_contact_name);
                  } else {
                    messageData.group_contact_name = `Contato ${messageData.phone}`;
                    console.log('‚ö†Ô∏è [DEBUG-NAMES] Usando nome padr√£o para contato no grupo:', messageData.group_contact_name);
                  }
                } else {
                  // Para contatos individuais: wpp_name = nome do contato (mesmo valor para contacts.name_wpp)
                  if (realContactName && realContactName.trim()) {
                    messageData.wpp_name = realContactName.trim();
                    console.log('‚úÖ [DEBUG-NAMES] Nome real do contato encontrado:', messageData.wpp_name);
                  } else {
                    // Tentar usar pushName da mensagem como fallback
                    if (message.pushName && message.pushName.trim()) {
                      messageData.wpp_name = message.pushName.trim();
                      console.log('‚úÖ [DEBUG-NAMES] Nome encontrado via pushName:', messageData.wpp_name);
                    } else {
                      messageData.wpp_name = `Contato ${messageData.phone}`;
                      console.log('‚ö†Ô∏è [DEBUG-NAMES] Usando nome padr√£o:', messageData.wpp_name);
                    }
                  }
                  messageData.group_contact_name = null; // N√£o √© grupo
                }
              } else {
                console.log('‚ö†Ô∏è Socket n√£o dispon√≠vel ou n√£o inicializado para buscar nome do contato');
                // Tentar usar pushName da mensagem como fallback
                if (message.pushName && message.pushName.trim()) {
                  messageData.wpp_name = message.pushName.trim();
                  console.log('‚úÖ Nome encontrado via pushName (fallback):', messageData.wpp_name);
                } else {
                  messageData.wpp_name = `Contato ${messageData.phone}`;
                  console.log('‚ÑπÔ∏è Usando nome padr√£o:', messageData.wpp_name);
                }
              }
              
            } catch (error) {
              console.error('‚ö†Ô∏è Erro ao buscar nome do contato:', error.message);
              // Tentar usar pushName da mensagem como fallback
              if (message.pushName && message.pushName.trim()) {
                messageData.wpp_name = message.pushName.trim();
                console.log('‚úÖ Nome encontrado via pushName (fallback ap√≥s erro):', messageData.wpp_name);
              } else {
                messageData.wpp_name = `Contato ${messageData.phone}`;
                console.log('‚ÑπÔ∏è Usando nome padr√£o ap√≥s erro:', messageData.wpp_name);
              }
            }
            
            // Criar ou atualizar contato automaticamente
            const connection = activeConnections.get(connectionId);
            const sock = connection?.sock;
            await createContactFromMessage(messageData, userId, sock);
          } else if (messageData.remetente === 'ATENDENTE') {
            // Para mensagens do atendente, usar o nome da conex√£o
            messageData.wpp_name = 'Atendente';
            messageData.group_contact_name = null;
            // Atualizar contato mesmo para mensagens do atendente
            await updateContactFromMessage(messageData, userId);
          }
          
          // Gerar Atendimento ID √∫nico para a conversa (UUID v√°lido)
          const { v4: uuidv4 } = require('uuid');
          messageData.atendimento_id = uuidv4();
          
          // Determinar status baseado no remetente
          if (messageData.remetente === 'CLIENTE') {
            messageData.status = 'AGUARDANDO'; // Cliente aguardando resposta
          } else if (messageData.remetente === 'AI') {
            messageData.status = 'AI'; // Resposta da IA
          } else {
            messageData.status = 'ATENDIDO'; // Resposta de operador humano
          }
          
          // M√≠dia j√° foi processada pela fun√ß√£o unificada acima
          
          // Salvar mensagem no banco
          console.log('üíæ [DATABASE] ===== SALVANDO MENSAGEM NO BANCO DE DADOS =====');
          console.log('üíæ [DATABASE] Dados principais:', {
            connection_id: messageData.connection_id,
            chat_id: messageData.chat_id,
            atendimento_id: messageData.atendimento_id,
            conteudo: messageData.conteudo?.substring(0, 50) + (messageData.conteudo?.length > 50 ? '...' : ''),
            remetente: messageData.remetente,
            wpp_name: messageData.wpp_name,
            group_contact_name: messageData.group_contact_name
          });
          
          console.log('üíæ [DATABASE] Informa√ß√µes de perfil WhatsApp:', {
            whatsapp_is_group: messageData.whatsapp_is_group,
            whatsapp_business_name: messageData.whatsapp_business_name,
            whatsapp_business_category: messageData.whatsapp_business_category,
            whatsapp_verified: messageData.whatsapp_verified,
            whatsapp_online: messageData.whatsapp_online,
            whatsapp_status: messageData.whatsapp_status,
            message_type: messageData.message_type
          });
          
          if (messageData.whatsapp_is_group) {
            console.log('üíæ [DATABASE] Informa√ß√µes do grupo:', {
              whatsapp_group_subject: messageData.whatsapp_group_subject,
              whatsapp_group_owner: messageData.whatsapp_group_owner,
              whatsapp_group_participants: messageData.whatsapp_group_participants?.length || 0
            });
          }
          
          const { error: insertError } = await supabase
            .from('whatsapp_mensagens')
            .insert(messageData);
          
          if (insertError) {
            console.error('‚ùå [DATABASE] Erro ao salvar mensagem:', insertError);
            console.error('‚ùå [DATABASE] Detalhes do erro:', {
              message: insertError.message,
              details: insertError.details,
              hint: insertError.hint
            });
            continue;
          } else {
            console.log('‚úÖ [DATABASE] Mensagem salva com sucesso no Supabase');
            console.log('‚úÖ [DATABASE] ID da mensagem:', messageData.message_id);
          }
          
          // Emitir para o frontend PRIMEIRO (n√£o bloquear recebimento)
          const roomName = `${connectionId}-${messageData.chat_id}`;
          console.log('üì° ===== EMITINDO MENSAGEM PARA FRONTEND =====');
          console.log('üì° Sala de destino:', roomName);
          console.log('üì° Dados da mensagem:', {
            chat_id: messageData.chat_id,
            conteudo: messageData.conteudo,
            remetente: messageData.remetente,
            message_id: messageData.message_id
          });
          
          // Verificar quantos clientes est√£o na sala
          const room = io.sockets.adapter.rooms.get(roomName);
          console.log('üì° Clientes na sala:', room ? room.size : 0);
          console.log('üì° IDs dos clientes na sala:', room ? Array.from(room) : []);
          
          // Criar objeto de mensagem para emitir
          const messageToEmit = {
            ...messageData,
            id: messageData.message_id
          };
          
          console.log('üì° Mensagem a ser emitida:', messageToEmit);
          
          io.to(roomName).emit('newMessage', messageToEmit);
          
          console.log('üì° Mensagem emitida com sucesso!');
          
          // LEFT PANE live update (connection-level room)
          const preview = messageData.conteudo || '[Mensagem]';
          console.log('üì° Emitindo conversation:updated para sala:', connectionId);
          
          const conversationUpdate = {
            connectionId,
            conversationId: messageData.chat_id,
            lastMessageAt: messageData.timestamp,
            last_message: messageData,
            preview,
            from: messageData.remetente, // 'CLIENTE' or 'ATENDENTE'
            unread_count_delta: messageData.remetente === 'CLIENTE' ? 1 : 0,
            // Adicionar nome_cliente para o frontend
            nome_cliente: messageData.wpp_name || `Contato ${messageData.phone}`,
            numero_cliente: messageData.phone
          };
          
          console.log('üì° [CONVERSATION-UPDATE] Dados sendo emitidos:', {
            conversationId: conversationUpdate.conversationId,
            nome_cliente: conversationUpdate.nome_cliente,
            wpp_name: messageData.wpp_name,
            phone: messageData.phone,
            from: conversationUpdate.from
          });
          
          console.log('üì° [CONVERSATION-UPDATE] Nome do contato:', {
            wpp_name: messageData.wpp_name,
            nome_cliente: conversationUpdate.nome_cliente,
            phone: messageData.phone
          });
          
          console.log('üì° Conversation update:', conversationUpdate);
          
          // Verificar se h√° clientes na sala antes de emitir
          const roomClients = io.sockets.adapter.rooms.get(connectionId);
          console.log('üì° Clientes na sala de conex√£o:', roomClients ? roomClients.size : 0);
          console.log('üì° IDs dos clientes na sala:', roomClients ? Array.from(roomClients) : []);
          
          io.to(connectionId).emit('conversation:updated', conversationUpdate);
          
          console.log('üì° Conversation updated emitido com sucesso!');
          
          // Verificar IA DEPOIS de emitir a mensagem (n√£o bloquear)
          if (messageData.remetente === 'CLIENTE') {
            // Executar verifica√ß√£o da IA de forma ass√≠ncrona (delay de 5 segundos para resposta)
            console.log('ü§ñ ===== AGENDANDO RESPOSTA IA EM 5 SEGUNDOS =====');
            console.log('ü§ñ Phone Number:', messageData.phone);
            console.log('ü§ñ User ID:', userId);
            setTimeout(async () => {
              try {
                console.log('ü§ñ ===== VERIFICANDO AGENTE IA (ASS√çNCRONO) =====');
                console.log('ü§ñ Chat ID:', messageData.chat_id);
                console.log('ü§ñ Mensagem:', messageData.conteudo);
                console.log('ü§ñ Connection ID:', connectionId);
                console.log('ü§ñ User ID:', userId);
                
                // Primeiro, tentar buscar pelo n√∫mero limpo
                let phoneToSearch = messageData.phone;
                if (phoneToSearch && phoneToSearch.includes('@')) {
                  phoneToSearch = phoneToSearch.split('@')[0];
                }
                
                console.log('ü§ñ Buscando contato com phone original:', messageData.phone);
                console.log('ü§ñ Phone limpo para busca:', phoneToSearch);
                console.log('ü§ñ User ID para busca:', userId);
                
                let { data: contactData, error: contactError } = await supabase
                  .from('contacts')
                  .select('ai_enabled, phone, name, id')
                  .eq('phone', phoneToSearch)
                  .eq('owner_id', userId)
                  .single();
                
                console.log('ü§ñ Resultado da busca do contato:', { contactData, contactError });
                
                // Se n√£o encontrar, tentar buscar sem owner_id (contatos globais)
                if (contactError && contactError.code === 'PGRST116') {
                  console.log('ü§ñ Tentando buscar contato sem owner_id...');
                  const { data: globalContactData, error: globalContactError } = await supabase
                    .from('contacts')
                    .select('ai_enabled, phone, name, id')
                    .eq('phone', phoneToSearch)
                    .single();
                  
                  console.log('ü§ñ Resultado da busca global:', { globalContactData, globalContactError });
                  
                  if (globalContactData) {
                    // Usar contato global se encontrado
                    contactData = globalContactData;
                    contactError = null;
                  }
                }
                
                if (contactError) {
                  console.log('ü§ñ Contato n√£o encontrado, criando automaticamente...');
                  console.log('ü§ñ Erro original:', contactError.message);
                  
                  // Criar contato automaticamente se n√£o existir
                  try {
                    const newContactData = {
                      name: `Contato ${phoneToSearch}`,
                      phone: phoneToSearch,
                      whatsapp_opted: true,
                      ai_enabled: false, // N√ÉO ativar IA por padr√£o - s√≥ ativar quando explicitamente escolhido
                      owner_id: userId,
                      created_at: new Date().toISOString(),
                      updated_at: new Date().toISOString(),
                      last_contact_at: new Date().toISOString()
                    };
                    
                    console.log('ü§ñ Criando novo contato:', newContactData);
                    
                    const { data: newContact, error: createError } = await supabase
                      .from('contacts')
                      .insert(newContactData)
                      .select()
                      .single();
                    
                    if (createError) {
                      console.error('‚ùå Erro ao criar contato:', createError);
                      console.log('‚ö†Ô∏è Continuando sem contato - IA pode funcionar sem ele');
                      // N√£o retornar - continuar o processamento
                    }
                    
                    console.log('‚úÖ Contato criado com sucesso:', newContact);
                    contactData = newContact;
                    contactError = null;
                    
                  } catch (createError) {
                    console.error('‚ùå Erro ao criar contato:', createError);
                    console.log('‚ö†Ô∏è Continuando sem contato - IA pode funcionar sem ele');
                    // N√£o retornar - continuar o processamento
                  }
                }
                
                const isAiEnabled = contactData?.ai_enabled === true;
                console.log('ü§ñ Dados do contato encontrado:', contactData);
                console.log('ü§ñ Agente IA ativado para este contato (banco):', isAiEnabled);
                
                // Verificar se h√° configura√ß√£o de IA ativa para o usu√°rio
                let { data: aiConfigData } = await supabaseAdmin
                  .from('ai_agent_configs')
                  .select('*')
                  .eq('owner_id', userId)
                  .eq('is_active', true)
                  .limit(1);
                
                // Se n√£o tem configura√ß√£o ativa, buscar qualquer configura√ß√£o do usu√°rio
                if (!aiConfigData || aiConfigData.length === 0) {
                  console.log('ü§ñ Buscando qualquer configura√ß√£o de IA para o usu√°rio...');
                  const { data: anyConfigData } = await supabaseAdmin
                    .from('ai_agent_configs')
                    .select('*')
                    .eq('owner_id', userId)
                    .limit(1);
                  
                  if (anyConfigData && anyConfigData.length > 0) {
                    aiConfigData = anyConfigData;
                    console.log('ü§ñ Configura√ß√£o de IA encontrada (n√£o ativa):', anyConfigData[0].name);
                  }
                }
                
                const hasActiveAIConfig = aiConfigData && aiConfigData.length > 0;
                console.log('ü§ñ Configura√ß√£o de IA encontrada:', hasActiveAIConfig);
                if (hasActiveAIConfig) {
                  console.log('ü§ñ Configura√ß√£o:', {
                    name: aiConfigData[0].name,
                    api_key: aiConfigData[0].api_key ? 'Configurada' : 'N√£o configurada',
                    is_active: aiConfigData[0].is_active
                  });
                }

                // Buscar dados da sess√£o para verificar Tipo de Atendimento
                let sessionData = null;
                try {
                  const { data: sessionResult, error: sessionError } = await supabaseAdmin
                    .from('whatsapp_sessions')
                    .select('attendance_type, connection_id')
                    .eq('owner_id', userId)
                    .eq('connection_id', connectionId)
                    .limit(1);
                  
                  if (!sessionError && sessionResult && sessionResult.length > 0) {
                    sessionData = sessionResult[0];
                    console.log('ü§ñ Dados da sess√£o:', sessionData);
                  } else {
                    console.log('ü§ñ Sess√£o n√£o encontrada ou erro:', sessionError?.message);
                  }
                } catch (sessionErr) {
                  console.log('ü§ñ Erro ao buscar sess√£o:', sessionErr.message);
                }
                
                // NOVA L√ìGICA: Prioridade para escolhas espec√≠ficas vs configura√ß√£o da conex√£o
                let shouldActivateAI = false;
                let activationReason = '';
                
                // 1. PRIORIDADE M√ÅXIMA: Se o contato j√° tem uma escolha espec√≠fica (dropdown do topbar)
                // Isso significa que o usu√°rio j√° interagiu com esta conversa espec√≠fica
                if (contactData && contactData.ai_enabled !== null) {
                  shouldActivateAI = contactData.ai_enabled;
                  activationReason = contactData.ai_enabled 
                    ? 'Escolha espec√≠fica do contato (dropdown do topbar) - IA HABILITADA'
                    : 'Escolha espec√≠fica do contato (dropdown do topbar) - IA DESABILITADA';
                  console.log('ü§ñ ' + activationReason);
                }
                // 2. FALLBACK: Se n√£o h√° escolha espec√≠fica, usar configura√ß√£o da conex√£o (modal de detalhes)
                // Isso se aplica apenas a NOVAS conversas
                else if (sessionData && sessionData.attendance_type === 'AI' && hasActiveAIConfig) {
                  shouldActivateAI = true;
                  activationReason = 'Configura√ß√£o da conex√£o (modal de detalhes) - NOVA conversa';
                  console.log('ü§ñ ' + activationReason);
                }
                // 3. PADR√ÉO: Se n√£o h√° configura√ß√£o, usar atendimento humano
                else {
                  shouldActivateAI = false;
                  activationReason = 'Nenhuma configura√ß√£o encontrada - Atendimento humano';
                  console.log('ü§ñ ' + activationReason);
                }
                console.log('ü§ñ ===== DECIS√ÉO DE ATIVA√á√ÉO DA IA =====');
                console.log('ü§ñ Motivo da ativa√ß√£o:', activationReason);
                console.log('ü§ñ hasActiveAIConfig:', hasActiveAIConfig);
                console.log('ü§ñ contactData.ai_enabled (escolha espec√≠fica):', contactData?.ai_enabled);
                console.log('ü§ñ sessionData.attendance_type (configura√ß√£o da conex√£o):', sessionData?.attendance_type);
                console.log('ü§ñ shouldActivateAI (decis√£o final):', shouldActivateAI);
                console.log('ü§ñ Configura√ß√£o da IA encontrada:', aiConfigData?.length > 0);
                if (aiConfigData?.length > 0) {
                  console.log('ü§ñ Configura√ß√£o da IA:', {
                    name: aiConfigData[0].name,
                    hasApiKey: !!aiConfigData[0].api_key,
                    isActive: aiConfigData[0].is_active,
                    hasKnowledgeBase: !!aiConfigData[0].knowledge_base
                  });
                }
                console.log('ü§ñ ======================================');
                
                if (shouldActivateAI) {
                  console.log('ü§ñ ===== ATIVANDO AGENTE IA =====');
                  console.log('ü§ñ Verifica√ß√µes de seguran√ßa:');
                  console.log('ü§ñ - Contato tem IA habilitada:', isAiEnabled);
                  console.log('ü§ñ - Configura√ß√£o ativa encontrada:', hasActiveAIConfig);
                  console.log('ü§ñ - Mensagem n√£o √© da pr√≥pria IA:', messageData.remetente !== 'AI');
                  
                  // Verifica√ß√£o de seguran√ßa: n√£o responder a mensagens da pr√≥pria IA
                  if (messageData.remetente === 'AI') {
                    console.log('ü§ñ ‚ö†Ô∏è Mensagem √© da pr√≥pria IA, ignorando para evitar loop');
                    return;
                  }
                  
                  console.log('ü§ñ Iniciando gera√ß√£o de resposta IA...');
                  
                  // Usar o sistema que funciona
                  const aiResponse = await generateAIResponse(messageData.conteudo, messageData.chat_id, messageData.message_type, userId, messageData.midia_url);
                  console.log('ü§ñ Resposta gerada pela IA:', aiResponse);
                  
                  if (aiResponse && aiResponse.trim() !== '') {
                    console.log('ü§ñ Resposta IA gerada, enviando para o contato...');
                    console.log('ü§ñ Chamando sendAIResponse com:', { connectionId, chatId: messageData.chat_id, response: aiResponse, userId });
                    await sendAIResponse(connectionId, messageData.chat_id, aiResponse, userId);
                    console.log('ü§ñ ‚úÖ Resposta IA enviada com sucesso!');
                  } else {
                    console.log('ü§ñ Nenhuma resposta IA gerada ou resposta vazia');
                  }
                } else {
                  console.log('ü§ñ Agente IA n√£o ativado para este contato');
                console.log('ü§ñ Raz√£o: isAiEnabled =', isAiEnabled, ', hasActiveAIConfig =', hasActiveAIConfig);
                console.log('ü§ñ Para ativar a IA:');
                console.log('ü§ñ 1. Configure uma API key na p√°gina de Agente IA');
                console.log('ü§ñ 2. Ou ative "Agente IA" no painel do contato');
                console.log('ü§ñ 3. Ou use o bot√£o "Ativar IA para Todos os Contatos"');
                }
              } catch (error) {
                console.error('‚ùå Erro ao verificar estado do agente IA:', error);
              }
            }, 5000);
          }
        }
      } catch (error) {
        console.error('Erro ao processar mensagens:', error);
      }
    });
    
    // Buscar session_name existente se connectionData estiver vazio (reconex√£o)
    let sessionName = connectionData.name;
    if (!sessionName) {
      try {
        const { data: existingSession } = await supabase
          .from('whatsapp_sessions')
          .select('session_name')
          .eq('connection_id', connectionId)
          .single();
        
        if (existingSession?.session_name) {
          sessionName = existingSession.session_name;
          console.log('üîç Usando session_name existente para reconex√£o:', sessionName);
        }
      } catch (error) {
        console.log('‚ö†Ô∏è Erro ao buscar session_name existente:', error.message);
      }
    }

    // Armazenar conex√£o
    const connectionInfo = {
      id: connectionId,
      name: sessionName || `Conex√£o ${connectionId}`,
      connectionState: 'disconnected',
      isConnected: false,
      phoneNumber: null,
      whatsappInfo: null,
      qrCode: null,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      sock
    };
    
    activeConnections.set(connectionId, connectionInfo);
    
    // Inicializar servi√ßo de sincroniza√ß√£o de perfil
    profileSyncService.initialize(sock);
    console.log('‚úÖ [PROFILE-SYNC] Servi√ßo de sincroniza√ß√£o inicializado para conex√£o:', connectionId);
    
    // Salvar sess√£o inicial no Supabase
    console.log(`üíæ Salvando sess√£o inicial para ${connectionId} com owner_id: ${userId}`);
    await saveSessionToSupabase(connectionId, {
      name: sessionName || `Conex√£o ${connectionId}`,
      status: 'disconnected',
      qr_code: null // Ser√° atualizado quando o QR Code for gerado
    }, userId);
    
    return sock;
  } catch (error) {
    console.error(`‚ùå Erro ao criar conex√£o WhatsApp para ${connectionId}:`, error);
    throw error;
  }
}

// Endpoints da API

// Health check endpoint
app.get('/api/baileys-simple/health', (req, res) => {
  res.json({
    success: true,
    status: 'healthy',
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    connections: activeConnections.size,
    version: '1.0.0'
  });
});

// Endpoint tempor√°rio para verificar mensagens
app.get('/api/baileys-simple/messages', async (req, res) => {
  try {
    const { ownerId, connectionId } = req.query;
    
    if (!ownerId) {
      return res.status(400).json({ error: 'ownerId √© obrigat√≥rio' });
    }

    let query = supabase
      .from('whatsapp_mensagens')
      .select('*')
      .eq('owner_id', ownerId)
      .order('timestamp', { ascending: false })
      .limit(50);

    if (connectionId) {
      query = query.eq('connection_id', connectionId);
    }

    const { data, error } = await query;

    if (error) {
      console.error('Erro ao buscar mensagens:', error);
      return res.status(500).json({ error: 'Erro ao buscar mensagens' });
    }

    res.json({
      success: true,
      data: data || [],
      count: data?.length || 0
    });
  } catch (error) {
    console.error('Erro no endpoint de mensagens:', error);
    res.status(500).json({ error: 'Erro interno do servidor' });
  }
});

// Endpoint para verificar estrutura da tabela
app.get('/api/baileys-simple/check-table', async (req, res) => {
  try {
    const { data, error } = await supabase
      .from('whatsapp_mensagens')
      .select('*')
      .limit(1);

    if (error) {
      console.error('Erro ao verificar tabela:', error);
      return res.status(500).json({ 
        error: 'Erro ao verificar tabela',
        details: error.message,
        code: error.code
      });
    }

    res.json({
      success: true,
      message: 'Tabela whatsapp_mensagens existe',
      sample: data?.[0] || 'Tabela vazia'
    });
  } catch (error) {
    console.error('Erro no endpoint de verifica√ß√£o:', error);
    res.status(500).json({ error: 'Erro interno do servidor' });
  }
});

// Endpoint para criar mensagens de teste
app.post('/api/baileys-simple/test-messages', async (req, res) => {
  try {
    const { ownerId, connectionId } = req.body;
    
    if (!ownerId || !connectionId) {
      return res.status(400).json({ error: 'ownerId e connectionId s√£o obrigat√≥rios' });
    }

    const testMessages = [
      {
        owner_id: ownerId,
        connection_id: connectionId,
        chat_id: '559999999999@s.whatsapp.net',
        phone: '559999999999',
        wpp_name: 'Jo√£o Silva',
        conteudo: 'Ol√°! Gostaria de saber mais sobre seus servi√ßos.',
        message_type: 'TEXTO',
        remetente: 'CLIENTE',
        lida: false,
        timestamp: new Date(Date.now() - 1000 * 60 * 30).toISOString() // 30 min atr√°s
      },
      {
        owner_id: ownerId,
        connection_id: connectionId,
        chat_id: '559999999999@s.whatsapp.net',
        phone: '559999999999',
        wpp_name: 'Jo√£o Silva',
        conteudo: 'Claro! Posso te ajudar com isso. Que tipo de servi√ßo voc√™ procura?',
        message_type: 'TEXTO',
        remetente: 'OPERADOR',
        lida: true,
        timestamp: new Date(Date.now() - 1000 * 60 * 25).toISOString() // 25 min atr√°s
      },
      {
        owner_id: ownerId,
        connection_id: connectionId,
        chat_id: '559999999999@s.whatsapp.net',
        phone: '559999999999',
        wpp_name: 'Jo√£o Silva',
        conteudo: 'Estou interessado em consultoria empresarial.',
        message_type: 'TEXTO',
        remetente: 'CLIENTE',
        lida: false,
        timestamp: new Date(Date.now() - 1000 * 60 * 20).toISOString() // 20 min atr√°s
      },
      {
        owner_id: ownerId,
        connection_id: connectionId,
        chat_id: '559888888888@s.whatsapp.net',
        phone: '559888888888',
        wpp_name: 'Maria Santos',
        conteudo: 'Bom dia! Preciso de ajuda com meu projeto.',
        message_type: 'TEXTO',
        remetente: 'CLIENTE',
        lida: false,
        timestamp: new Date(Date.now() - 1000 * 60 * 10).toISOString() // 10 min atr√°s
      }
    ];

    const { data, error } = await supabase
      .from('whatsapp_mensagens')
      .insert(testMessages)
      .select();

    if (error) {
      console.error('Erro ao inserir mensagens de teste:', error);
      return res.status(500).json({ 
        error: 'Erro ao inserir mensagens de teste',
        details: error.message,
        code: error.code
      });
    }

    res.json({
      success: true,
      data: data,
      message: 'Mensagens de teste criadas com sucesso'
    });
  } catch (error) {
    console.error('Erro no endpoint de mensagens de teste:', error);
    res.status(500).json({ error: 'Erro interno do servidor' });
  }
});

// Endpoint tempor√°rio para testar session_status
app.get('/api/baileys-simple/test-session-status', async (req, res) => {
  try {
    console.log('üîç Testando coluna session_status...');
    
    // Buscar profiles
    const { data: profiles, error: profilesError } = await supabase
      .from('profiles')
      .select('id, email, session_status')
      .limit(3);
    
    if (profilesError) {
      console.error('‚ùå Erro ao buscar profiles:', profilesError);
      return res.status(500).json({
        success: false,
        error: 'Erro ao buscar profiles',
        details: profilesError
      });
    }
    
    console.log('üìã Profiles encontrados:', profiles.length);
    
    // Tentar atualizar session_status
    console.log('üîÑ Testando atualiza√ß√£o...');
    const { error: updateError } = await supabase
      .from('profiles')
      .update({ session_status: 'connected' })
      .eq('id', '905b926a-785a-4f6d-9c3a-9455729500b3');
    
    if (updateError) {
      console.error('‚ùå Erro ao atualizar:', updateError);
      return res.status(500).json({
        success: false,
        error: 'Erro ao atualizar session_status',
        details: updateError
      });
    }
    
    console.log('‚úÖ Atualiza√ß√£o bem-sucedida!');
    
    res.json({
      success: true,
      message: 'Teste de session_status conclu√≠do',
      profiles: profiles,
      updateResult: 'success'
    });
    
  } catch (error) {
    console.error('‚ùå Erro geral:', error);
    res.status(500).json({
      success: false,
      error: 'Erro geral',
      details: error.message
    });
  }
});

// Login do usu√°rio (atualizar session_status para connected)
app.post('/api/baileys-simple/login', async (req, res) => {
  try {
    const { user_id } = req.body;
    
    if (!user_id) {
      return res.status(400).json({
        success: false,
        error: 'user_id √© obrigat√≥rio'
      });
    }
    
    // Primeiro, definir todos os usu√°rios como disconnected
    await supabase
      .from('profiles')
      .update({ session_status: 'disconnected' });
    
    // Depois, definir o usu√°rio espec√≠fico como connected
    const { error } = await supabase
      .from('profiles')
      .update({ session_status: 'connected' })
      .eq('id', user_id);
    
    if (error) {
      console.error('‚ùå Erro ao fazer login:', error);
      return res.status(500).json({
        success: false,
        error: 'Erro ao fazer login'
      });
    }
    
    console.log(`‚úÖ Usu√°rio ${user_id} fez login (session_status = connected)`);
    res.json({
      success: true,
      message: 'Login realizado com sucesso'
    });
  } catch (error) {
    console.error('‚ùå Erro no login:', error);
    res.status(500).json({
      success: false,
      error: 'Erro no login'
    });
  }
});

// Logout do usu√°rio (atualizar session_status para disconnected)
app.post('/api/baileys-simple/logout', async (req, res) => {
  try {
    const { user_id } = req.body;
    
    if (!user_id) {
      return res.status(400).json({
        success: false,
        error: 'user_id √© obrigat√≥rio'
      });
    }
    
    const { error } = await supabase
      .from('profiles')
      .update({ session_status: 'disconnected' })
      .eq('id', user_id);
    
    if (error) {
      console.error('‚ùå Erro ao fazer logout:', error);
      return res.status(500).json({
        success: false,
        error: 'Erro ao fazer logout'
      });
    }
    
    console.log(`‚úÖ Usu√°rio ${user_id} fez logout (session_status = disconnected)`);
    res.json({
      success: true,
      message: 'Logout realizado com sucesso'
    });
  } catch (error) {
    console.error('‚ùå Erro no logout:', error);
    res.status(500).json({
      success: false,
      error: 'Erro no logout'
    });
  }
});

// Listar conex√µes
app.get('/api/baileys-simple/connections', async (req, res) => {
  try {
    // Buscar usu√°rio ativo (session_status = 'connected')
    const activeUser = await getActiveUser();
    if (!activeUser) {
      return res.status(400).json({
        success: false,
        error: 'Nenhum usu√°rio ativo encontrado. Fa√ßa login primeiro.'
      });
    }
    
    const userId = activeUser.id;
    console.log(`üìã Listando conex√µes para usu√°rio ativo: ${activeUser.email} (${userId})`);
    
    // Carregar todas as sess√µes do usu√°rio espec√≠fico do Supabase
    console.log(`üîç Buscando sess√µes para userId: ${userId}`);
    const { data: sessions, error } = await supabase
      .from('whatsapp_sessions')
      .select('*')
      .eq('owner_id', userId)
      .order('updated_at', { ascending: false });
    
    if (error) {
      console.error('‚ùå Erro ao carregar sess√µes do Supabase:', error);
      return res.status(500).json({
        success: false,
        error: 'Erro ao carregar conex√µes'
      });
    }
    
    console.log(`üìã Encontradas ${sessions?.length || 0} sess√µes no Supabase`);
    
    // Remover duplicatas baseado em connection_id (manter apenas a mais recente)
    const uniqueSessions = [];
    const seenConnectionIds = new Set();
    
    for (const session of sessions || []) {
      if (!seenConnectionIds.has(session.connection_id)) {
        seenConnectionIds.add(session.connection_id);
        uniqueSessions.push(session);
      }
    }
    
    // Filtrar apenas conex√µes que est√£o ativas no servidor E realmente conectadas
    const activeConnectionsList = Array.from(activeConnections.values());
    
    // Filtrar sess√µes Baileys: apenas mostrar as conectadas (com phone)
    const filteredSessions = uniqueSessions.filter(session => {
      // Para Baileys: s√≥ mostrar se estiver conectado (tem phone)
      const isConnected = session.phone && session.status === 'connected';
      return isConnected;
    });

    const connections = filteredSessions.map(session => {
      const activeConn = activeConnectionsList.find(conn => conn.id === session.connection_id);
      
      // Para Baileys: conectado APENAS se tem phone (WhatsApp realmente conectou)
      const isConnected = session.phone && session.status === 'connected';
      
      const connectionData = {
        id: session.connection_id,
        name: session.session_name || `Conex√£o ${session.connection_id}`,
        type: 'whatsapp_baileys', // Sempre WhatsApp Baileys para sess√µes do Baileys
        connectionState: 'connected', // S√≥ retornamos as conectadas
        isConnected: true, // S√≥ retornamos as conectadas
        phoneNumber: session.phone || null,
        whatsappId: session.whatsapp_id || null,
        whatsappInfo: session.whatsapp_info || null,
        qrCode: null, // N√£o mostrar QR code para conectadas
        createdAt: session.created_at,
        updatedAt: session.updated_at,
        connectedAt: session.connected_at,
        owner_id: session.owner_id // Adicionar owner_id
      };
      
      console.log('üîç Mapeando sess√£o para conex√£o:', {
        connection_id: session.connection_id,
        session_name: session.session_name,
        name_final: connectionData.name
      });
      
      return connectionData;
    });
    
    console.log(`‚úÖ Encontradas ${connections.length} conex√µes para usu√°rio ${userId}`);
    
    res.json({
      success: true,
      data: connections
    });
  } catch (error) {
    console.error('Erro ao listar conex√µes:', error);
    res.status(500).json({
      success: false,
      error: 'Erro interno do servidor'
    });
  }
});

// Criar nova conex√£o
app.post('/api/baileys-simple/connections', async (req, res) => {
  try {
    const { name, type } = req.body;
    console.log('üîç POST /api/baileys-simple/connections - Dados recebidos:', { name, type, body: req.body });
    
    // Buscar usu√°rio ativo (session_status = 'connected')
    const activeUser = await getActiveUser();
    if (!activeUser) {
      return res.status(400).json({
        success: false,
        error: 'Nenhum usu√°rio ativo encontrado. Fa√ßa login primeiro.'
      });
    }
    
    const userId = activeUser.id;
    console.log(`üÜï Criando conex√£o para usu√°rio ativo: ${activeUser.email} (${userId})`);
    
    // Verificar conex√µes existentes do usu√°rio espec√≠fico no Supabase
    const { data: existingSessions, error: checkError } = await supabase
      .from('whatsapp_sessions')
      .select('*')
      .eq('owner_id', userId)
      .eq('status', 'connected')
      .not('connection_id', 'is', null);
    
    if (checkError) {
      console.error('Erro ao verificar conex√µes existentes:', checkError);
      return res.status(500).json({
        success: false,
        error: 'Erro ao verificar conex√µes existentes'
      });
    }
    
    // Verificar se j√° atingiu o limite de 5 conex√µes para este usu√°rio
    const activeConnectionsCount = existingSessions ? existingSessions.length : 0;
    const maxConnections = 5;
    
    if (activeConnectionsCount >= maxConnections) {
      console.log(`‚ö†Ô∏è Limite de conex√µes atingido para usu√°rio ${userId}. Ativas: ${activeConnectionsCount}/${maxConnections}`);
      
      return res.status(409).json({
        success: false,
        error: `Limite m√°ximo de ${maxConnections} conex√µes WhatsApp atingido. Desconecte uma conex√£o existente para criar uma nova.`,
        code: 'MAX_CONNECTIONS_REACHED',
        data: {
          activeConnections: activeConnectionsCount,
          maxConnections: maxConnections
        }
      });
    }
    
    // Verificar se h√° conex√µes ativas com o mesmo n√∫mero de telefone
    // (Esta verifica√ß√£o ser√° feita ap√≥s a conex√£o ser estabelecida e o n√∫mero ser obtido)
    // Por enquanto, permitimos a cria√ß√£o da conex√£o
    
    const connectionId = `connection_${Date.now()}`;
    
    console.log(`üÜï Criando nova conex√£o: ${connectionId} para owner_id: ${userId}`);
    
    // Criar conex√£o WhatsApp
    await createWhatsAppConnection(connectionId, userId, { name });
    
    res.json({
      success: true,
      data: {
        connectionId: connectionId,
        name: name || `Conex√£o ${connectionId}`,
        type: type || 'whatsapp_baileys',
        status: 'disconnected'
      }
    });
  } catch (error) {
    console.error('Erro ao criar conex√£o:', error);
    res.status(500).json({
      success: false,
      error: 'Erro ao criar conex√£o'
    });
  }
});

// Obter QR Code
app.get('/api/baileys-simple/connections/:connectionId/qr', async (req, res) => {
  try {
    const { connectionId } = req.params;
    const connection = activeConnections.get(connectionId);
    
    if (!connection) {
      return res.status(404).json({
        success: false,
        error: 'Conex√£o n√£o encontrada'
      });
    }
    
    // Buscar QR code do Supabase se n√£o estiver na mem√≥ria
    let qrCode = connection.qrCode;
    if (!qrCode) {
      const { data: session, error } = await supabase
        .from('whatsapp_sessions')
        .select('qr_code, status')
        .eq('connection_id', connectionId)
        .single();
      
      if (!error && session) {
        qrCode = session.qr_code;
      }
    }
    
    res.json({
      success: true,
      data: {
        qrCode: qrCode,
        connectionState: connection.connectionState,
        isConnected: connection.isConnected
      }
    });
  } catch (error) {
    console.error('Erro ao obter QR code:', error);
    res.status(500).json({
      success: false,
      error: 'Erro ao obter QR code'
    });
  }
});

// Obter informa√ß√µes da conex√£o
app.get('/api/baileys-simple/connections/:connectionId/info', async (req, res) => {
  try {
    const { connectionId } = req.params;
    const connection = activeConnections.get(connectionId);
    
    if (!connection) {
      return res.status(404).json({
        success: false,
        error: 'Conex√£o n√£o encontrada'
      });
    }
    
    res.json({
      success: true,
      data: {
        id: connection.id,
        name: connection.name,
        connectionState: connection.connectionState,
        isConnected: connection.isConnected,
        phoneNumber: connection.phoneNumber,
        whatsappInfo: connection.whatsappInfo,
        createdAt: connection.createdAt,
        updatedAt: connection.updatedAt
      }
    });
  } catch (error) {
    console.error('Erro ao obter informa√ß√µes da conex√£o:', error);
    res.status(500).json({
      success: false,
      error: 'Erro ao obter informa√ß√µes da conex√£o'
    });
  }
});

// Refresh QR code
app.post('/api/baileys-simple/connections/:connectionId/refresh-qr', async (req, res) => {
  try {
    const { connectionId } = req.params;
    const connection = activeConnections.get(connectionId);
    
    if (!connection) {
      return res.status(404).json({
        success: false,
        error: 'Conex√£o n√£o encontrada'
      });
    }
    
    console.log(`üîÑ Refreshing QR code para ${connectionId}`);
    
    // Reconnect to generate new QR
    if (connection.sock) {
      connection.sock.logout();
    }
    
    await createWhatsAppConnection(connectionId);
    
    res.json({
      success: true,
      message: 'QR code refresh iniciado'
    });
  } catch (error) {
    console.error('Erro ao refresh QR code:', error);
    res.status(500).json({
      success: false,
      error: 'Erro ao refresh QR code'
    });
  }
});

// Enviar mensagem
app.post('/api/baileys-simple/connections/:connectionId/send-message', async (req, res) => {
  try {
    const { connectionId } = req.params;
    const { chatId, type = 'text', text, mediaUrl } = req.body || {};

    console.log('üì§ [SEND-MESSAGE] Recebida requisi√ß√£o:', { connectionId, chatId, type, text: text?.substring(0, 50), mediaUrl });

    const connection = activeConnections.get(connectionId);
    if (!connection || !connection.sock) {
      console.error(`‚ùå [SEND-MESSAGE] Conex√£o n√£o encontrada: ${connectionId}`);
      console.error(`‚ùå [SEND-MESSAGE] Conex√µes ativas:`, Array.from(activeConnections.keys()));
      return res.status(404).json({ ok: false, error: 'Connection not found' });
    }
    
    const sock = connection.sock;

    const jid = ensureJid(chatId);

    let content;
    if (type === 'text' || !mediaUrl) {
      const body = (text || '').trim();
      if (!body) return res.status(400).json({ ok: false, error: 'Empty message' });
      content = { text: body };
    } else {
      const fetchFn = global.fetch || ((...a) => import('node-fetch').then(({ default: f }) => f(...a)));
      const r = await fetchFn(mediaUrl);
      if (!r.ok) throw new Error(`Failed to fetch media: ${r.status}`);
      const buf = Buffer.from(await r.arrayBuffer());

      if (type === 'image') content = { image: buf, caption: text || '' };
      else if (type === 'video') content = { video: buf, caption: text || '' };
      else if (type === 'audio') {
        // Usar abordagem recomendada do Baileys para √°udio
        // Tentar diferentes formatos para compatibilidade
        try {
          content = { 
            audio: buf, 
            ptt: true, // Push-to-talk (√°udio de voz)
            mimetype: 'audio/ogg; codecs=opus' // Formato otimizado para WhatsApp
          };
        } catch (error) {
          console.log('üîÑ Tentando formato alternativo para √°udio...');
          content = { 
            audio: buf, 
            ptt: true
          };
        }
      } else content = { document: buf, fileName: 'file' };
    }

    // 1) ENVIAR VIA BAILEYS
    console.log('üì§ [SEND-MESSAGE] Enviando via Baileys:', { jid, content });
    const sent = await sock.sendMessage(jid, content, { 
      linkPreview: false,
      quoted: undefined 
    });
    console.log('‚úÖ [SEND-MESSAGE] Mensagem enviada via Baileys:', { messageId: sent?.key?.id });

    // 2) SALVAR M√çDIA NO SUPABASE STORAGE SE NECESS√ÅRIO
    let finalMediaUrl = mediaUrl || null;
    if (type !== 'text' && mediaUrl && (type === 'image' || type === 'video' || type === 'audio')) {
      try {
        // Baixar m√≠dia da URL e fazer upload para Supabase Storage
        const fetchFn = global.fetch || ((...a) => import('node-fetch').then(({ default: f }) => f(...a)));
        const response = await fetchFn(mediaUrl);
        if (response.ok) {
          const buffer = Buffer.from(await response.arrayBuffer());
          const fileName = `media_${Date.now()}_${Math.random().toString(36).substr(2, 9)}.${type === 'image' ? 'jpg' : type === 'video' ? 'mp4' : 'ogg'}`;
          
          // Upload para Supabase Storage
          const { error: uploadError } = await supabaseAdmin.storage
            .from('whatsapp')
            .upload(fileName, buffer, {
              contentType: type === 'image' ? 'image/jpeg' : type === 'video' ? 'video/mp4' : 'audio/ogg',
              upsert: false
            });
          
          if (!uploadError) {
            // Criar URL p√∫blica
            const { data: signedUrl } = await supabaseAdmin.storage
              .from('whatsapp')
              .createSignedUrl(fileName, 60 * 60 * 24 * 30); // 30 dias
            
            if (signedUrl) {
              finalMediaUrl = signedUrl.signedUrl;
              console.log('‚úÖ [SEND-MESSAGE] M√≠dia salva no Supabase Storage:', finalMediaUrl);
            }
          }
        }
      } catch (uploadError) {
        console.error('‚ùå [SEND-MESSAGE] Erro ao salvar m√≠dia no Supabase:', uploadError);
      }
    }

    // 3) SALVAR COMO MENSAGEM "REAL"
    console.log('üíæ [SEND-MESSAGE] Obtendo informa√ß√µes da sess√£o...');
    const { ownerId, connectionPhone } = await getSessionInfo(connectionId, supabase);
    const nowIso = new Date().toISOString();
    console.log('üíæ [SEND-MESSAGE] Informa√ß√µes da sess√£o:', { ownerId, connectionPhone });

    const row = {
      id: crypto.randomUUID(),
      owner_id: ownerId,
      atendimento_id: null,
      connection_id: connectionId,
      connection_phone: connectionPhone,
      chat_id: jid,
      phone: jid.split('@')[0],
      conteudo: typeof content?.text === 'string' ? content.text : (text || (type === 'image' ? '[Imagem]' : type === 'video' ? '[V√≠deo]' : type === 'audio' ? '[√Åudio]' : '[Arquivo]')),
      message_id: sent?.key?.id ?? null,
      message_type: type === 'text' ? 'TEXTO'
                   : type === 'image' ? 'IMAGEM'
                   : type === 'video' ? 'VIDEO'
                   : type === 'audio' ? 'AUDIO'
                   : 'ARQUIVO',
      media_type: type !== 'text' ? (type === 'image' ? 'image/jpeg' : type === 'video' ? 'video/mp4' : 'audio/ogg') : null,
      remetente: 'ATENDENTE',          // manter consistente com UI/DB
      status: 'ATENDIDO',
      timestamp: nowIso,
      lida: true,
      media_url: finalMediaUrl,
      media_mime: type !== 'text' ? (type === 'image' ? 'image/jpeg' : type === 'video' ? 'video/mp4' : 'audio/ogg') : null,
      duration_ms: null,
      wpp_name: null
    };

    console.log('üíæ [SEND-MESSAGE] Salvando no Supabase:', row);
    const { error: dbErr } = await supabase.from('whatsapp_mensagens').insert(row);
    if (dbErr) {
      console.error('‚ùå [SEND-MESSAGE] Erro ao salvar no Supabase:', dbErr);
    } else {
      console.log('‚úÖ [SEND-MESSAGE] Mensagem salva no Supabase com sucesso');
      
      // ü§ñ IA N√ÉO √â MAIS DESATIVADA AUTOMATICAMENTE quando operador envia mensagem
      // A IA s√≥ √© desativada quando o usu√°rio clica explicitamente no bot√£o "Voc√™"
      console.log('ü§ñ [SEND-MESSAGE] IA permanece ativa - n√£o desativando automaticamente');
    }

    // 3) EMITIR EM TEMPO REAL
    const roomName = `${connectionId}-${jid}`;
    console.log('üì° [SEND-MESSAGE] Emitindo newMessage para sala:', roomName);
    console.log('üì° [SEND-MESSAGE] Dados da mensagem:', {
      chat_id: jid,
      conteudo: row.conteudo,
      remetente: row.remetente,
      messageId: row.id
    });
    
    // Verificar se a sala existe antes de emitir
    const roomClients = io.sockets.adapter.rooms.get(roomName);
    console.log('üì° [SEND-MESSAGE] Clientes na sala:', roomClients ? roomClients.size : 0);
    
    io.to(roomName).emit('newMessage', row);
    
    // Verificar se h√° clientes na sala de conex√£o antes de emitir
    const connectionRoomClients = io.sockets.adapter.rooms.get(connectionId);
    console.log('üì° [SEND-MESSAGE] Clientes na sala de conex√£o:', connectionRoomClients ? connectionRoomClients.size : 0);
    
    io.to(connectionId).emit('conversation:updated', {
      connectionId,
      conversationId: jid,
      lastMessageAt: nowIso,
      last_message: row,
      preview: row.conteudo || '[Mensagem]',
      from: 'ATENDENTE',
      unread_count_delta: 0,
      // Adicionar nome_cliente para o frontend
      nome_cliente: row.wpp_name || `Contato ${row.phone}`,
      numero_cliente: row.phone
    });

    console.log('‚úÖ [SEND-MESSAGE] Processo completo finalizado');
    return res.json({ ok: true, messageId: sent?.key?.id || null });
  } catch (e) {
    console.error('send-message error:', e);
    return res.status(500).json({ ok: false, error: String(e?.message || e) });
  }
});

// Enviar m√≠dia (imagem, v√≠deo, √°udio, documento)
app.post('/api/baileys-simple/send-media', upload.single('file'), async (req, res) => {
  try {
    const { connectionId, jid, type } = req.body;
    const file = req.file;

    console.log('üì§ [SEND-MEDIA] Recebida requisi√ß√£o:', { connectionId, jid, type, fileName: file?.originalname });

    if (!connectionId || !jid || !type || !file) {
      return res.status(400).json({ 
        success: false, 
        error: 'connectionId, jid, type e file s√£o obrigat√≥rios' 
      });
    }

    const connection = activeConnections.get(connectionId);
    if (!connection || !connection.sock) {
      console.error(`‚ùå [SEND-MEDIA] Conex√£o n√£o encontrada: ${connectionId}`);
      return res.status(404).json({ 
        success: false, 
        error: 'Connection not found' 
      });
    }
    
    const sock = connection.sock;
    const chatJid = ensureJid(jid);

    // Preparar conte√∫do baseado no tipo
    let content;
    const fileBuffer = fs.readFileSync(file.path);
    
    switch (type) {
      case 'image':
        // Usar URL local para envio mais eficiente
        if (fs.existsSync(file.path)) {
          console.log('üìÅ [SEND-MEDIA] Usando arquivo local para imagem:', file.path);
          content = { 
            image: { url: file.path }, 
            caption: req.body.caption || ''
          };
        } else {
          // Fallback para buffer
          content = { 
            image: fileBuffer, 
            caption: req.body.caption || '',
            mimetype: file.mimetype
          };
        }
        break;
      case 'video':
        // Usar URL local para envio mais eficiente
        if (fs.existsSync(file.path)) {
          console.log('üìÅ [SEND-MEDIA] Usando arquivo local para v√≠deo:', file.path);
          content = { 
            video: { url: file.path }, 
            caption: req.body.caption || ''
          };
        } else {
          // Fallback para buffer
          content = { 
            video: fileBuffer, 
            caption: req.body.caption || '',
            mimetype: file.mimetype
          };
        }
        break;
      case 'audio':
        // Usar URL local para envio mais eficiente
        if (fs.existsSync(file.path)) {
          console.log('üìÅ [SEND-MEDIA] Usando arquivo local para √°udio:', file.path);
          content = { 
            audio: { url: file.path }, 
            ptt: true,
            mimetype: 'audio/ogg; codecs=opus'
          };
        } else {
          // Fallback para buffer
          content = { 
            audio: fileBuffer, 
            ptt: true,
            mimetype: file.mimetype
          };
        }
        break;
      case 'document':
        content = { 
          document: fileBuffer, 
          fileName: file.originalname,
          mimetype: file.mimetype
        };
        break;
      default:
        return res.status(400).json({ 
          success: false, 
          error: 'Tipo de m√≠dia n√£o suportado' 
        });
    }

    // Enviar via Baileys
    console.log('üì§ [SEND-MEDIA] Enviando via Baileys:', { chatJid, type });
    const sent = await sock.sendMessage(chatJid, content, { 
      linkPreview: false,
      quoted: undefined 
    });
    console.log('‚úÖ [SEND-MEDIA] M√≠dia enviada via Baileys:', { messageId: sent?.key?.id });

    // Salvar no banco
    const { ownerId, connectionPhone } = await getSessionInfo(connectionId, supabase);
    const nowIso = new Date().toISOString();

    // Salvar m√≠dia no Supabase Storage e obter URL
    let mediaUrl = null;
    try {
      const fileName = `media_${Date.now()}_${Math.random().toString(36).substr(2, 9)}.${file.mimetype.split('/')[1] || 'bin'}`;
      
      // Upload para Supabase Storage
      const { error: uploadError } = await supabaseAdmin.storage
        .from('whatsapp')
        .upload(fileName, fs.readFileSync(file.path), {
          contentType: file.mimetype,
          upsert: false
        });
      
      if (uploadError) {
        console.error('‚ùå [SEND-MEDIA] Erro ao fazer upload da m√≠dia:', uploadError);
      } else {
        console.log('‚úÖ [SEND-MEDIA] M√≠dia salva no Supabase:', fileName);
        
        // Criar URL p√∫blica
        const { data: signedUrl } = await supabaseAdmin.storage
          .from('whatsapp')
          .createSignedUrl(fileName, 60 * 60 * 24 * 30); // 30 dias
        
        if (signedUrl) {
          mediaUrl = signedUrl.signedUrl;
          console.log('‚úÖ [SEND-MEDIA] URL p√∫blica criada:', mediaUrl);
        }
      }
    } catch (uploadError) {
      console.error('‚ùå [SEND-MEDIA] Erro ao salvar m√≠dia no Supabase:', uploadError);
    }

    const row = {
      id: crypto.randomUUID(),
      owner_id: ownerId,
      atendimento_id: null,
      connection_id: connectionId,
      connection_phone: connectionPhone,
      chat_id: chatJid,
      phone: chatJid.split('@')[0],
      conteudo: content.caption || `[${type.toUpperCase()}]`,
      message_id: sent?.key?.id ?? null,
      message_type: type.toUpperCase(),
      media_type: file.mimetype,
      remetente: 'ATENDENTE',
      status: 'ATENDIDO',
      timestamp: nowIso,
      lida: true,
      media_url: mediaUrl, // URL da m√≠dia no Supabase Storage
      media_mime: file.mimetype,
      duration_ms: null,
      wpp_name: null
    };

    console.log('üíæ [SEND-MEDIA] Salvando no Supabase:', row);
    const { error: dbErr } = await supabase.from('whatsapp_mensagens').insert(row);
    if (dbErr) {
      console.error('‚ùå [SEND-MEDIA] Erro ao salvar no Supabase:', dbErr);
    } else {
      console.log('‚úÖ [SEND-MEDIA] M√≠dia salva no Supabase com sucesso');
    }

    // Emitir em tempo real
    const roomName = `${connectionId}-${chatJid}`;
    io.to(roomName).emit('newMessage', row);
    
    io.to(connectionId).emit('conversation:updated', {
      connectionId,
      conversationId: chatJid,
      lastMessageAt: nowIso,
      last_message: row,
      preview: `[${type.toUpperCase()}]`,
      from: 'ATENDENTE',
      unread_count_delta: 0,
      // Adicionar nome_cliente para o frontend
      nome_cliente: row.wpp_name || `Contato ${row.phone}`,
      numero_cliente: row.phone
    });

    // Limpar arquivo tempor√°rio
    fs.unlinkSync(file.path);

    console.log('‚úÖ [SEND-MEDIA] Processo completo finalizado');
    return res.json({ 
      success: true, 
      data: {
        messageId: sent?.key?.id,
        type: type,
        fileName: file.originalname
      }
    });
  } catch (e) {
    console.error('‚ùå [SEND-MEDIA] Erro:', e);
    return res.status(500).json({ 
      success: false, 
      error: String(e?.message || e) 
    });
  }
});

// Mark messages as read for a chat (DB + realtime broadcast)
// Keeps UI badge at 0 even after refresh.
app.post('/api/baileys-simple/connections/:connectionId/mark-read', async (req, res) => {
  const { connectionId } = req.params;
  const { chatId } = req.body || {};
  if (!connectionId || !chatId) return res.status(400).json({ ok: false, error: 'connectionId and chatId required' });

  try {
    console.log(`üìñ Marcando conversa como lida: ${chatId} para conex√£o: ${connectionId}`);
    
    // Primeiro, verificar quantas mensagens n√£o lidas existem
    const { data: unreadMessages, error: countError } = await supabase
      .from('whatsapp_mensagens')
      .select('id')
      .eq('connection_id', connectionId)
      .eq('chat_id', chatId)
      .eq('remetente', 'CLIENTE')
      .eq('lida', false);

    if (countError) throw countError;
    
    console.log(`üîç Encontradas ${unreadMessages?.length || 0} mensagens n√£o lidas para ${chatId}`);

    const { error, count } = await supabase
      .from('whatsapp_mensagens')
      .update({ lida: true })
      .eq('connection_id', connectionId)
      .eq('chat_id', chatId)
      .eq('remetente', 'CLIENTE')         // only customer messages count as unread
      .eq('lida', false)
      .select('id', { count: 'exact' });

    if (error) throw error;

    console.log(`‚úÖ ${count} mensagens marcadas como lidas para ${chatId}`);

    // Let all clients for this connection know unread=0 for this conversation
    io.to(connectionId).emit('conversation:read', {
      connectionId,
      conversationId: chatId,
      unread_count: 0,
    });

    console.log(`üì° Emitindo conversation:read para ${connectionId} - ${chatId}`);

    return res.json({ ok: true, count });
  } catch (e) {
    console.error('mark-read error:', e);
    return res.status(500).json({ ok: false, error: String(e?.message || e) });
  }
});

// Finalizar conversa
app.post('/api/baileys-simple/connections/:connectionId/finalizar-conversa', async (req, res) => {
  const { connectionId } = req.params;
  const { chatId } = req.body || {};
  if (!connectionId || !chatId) return res.status(400).json({ ok: false, error: 'connectionId and chatId required' });

  try {
    console.log(`üî¥ Finalizando conversa: ${chatId} para conex√£o: ${connectionId}`);
    
    // Atualizar status de todas as mensagens da conversa para FINALIZADO
    const { error: updateError, count } = await supabase
      .from('whatsapp_mensagens')
      .update({ status: 'FINALIZADO' })
      .eq('connection_id', connectionId)
      .eq('chat_id', chatId);

    if (updateError) throw updateError;

    console.log(`‚úÖ ${count} mensagens marcadas como FINALIZADO para ${chatId}`);

    // Emitir evento para atualizar frontend
    io.to(connectionId).emit('conversation:finalized', {
      connectionId,
      conversationId: chatId,
      status: 'FINALIZADO'
    });

    console.log(`üì° Emitindo conversation:finalized para ${connectionId} - ${chatId}`);

    return res.json({ ok: true, count });
  } catch (e) {
    console.error('finalizar-conversa error:', e);
    return res.status(500).json({ ok: false, error: String(e?.message || e) });
  }
});

// Endpoint para alterar modo de atendimento (dropdown)
app.post('/api/baileys-simple/atendimentos/change-mode', async (req, res) => {
  try {
    const { chatId, mode, connectionId } = req.body;
    
    if (!chatId || !mode || !connectionId) {
      return res.status(400).json({ 
        ok: false, 
        error: 'chatId, mode e connectionId s√£o obrigat√≥rios' 
      });
    }
    
    if (!['human', 'ai'].includes(mode)) {
      return res.status(400).json({ 
        ok: false, 
        error: 'Mode deve ser "human" ou "ai"' 
      });
    }
    
    console.log(`üîÑ Alterando modo de atendimento para ${mode} no chat ${chatId}`);
    
    // Buscar o contato pelo chat_id
    const phoneNumber = chatId.replace('@s.whatsapp.net', '');
    const { data: contactData, error: contactError } = await supabase
      .from('contacts')
      .select('id, phone, name, ai_enabled')
      .eq('phone', phoneNumber)
      .eq('owner_id', req.user?.id)
      .single();
    
    if (contactError || !contactData) {
      console.log('‚ö†Ô∏è Contato n√£o encontrado, criando novo contato');
      
      // Criar novo contato se n√£o existir
      // Para novas conversas, usar o attendance_type da conex√£o como padr√£o
      let defaultAiEnabled = false;
      try {
        const { data: sessionData } = await supabase
          .from('whatsapp_sessions')
          .select('attendance_type')
          .eq('owner_id', req.user?.id)
          .eq('connection_id', connectionId)
          .single();
        
        if (sessionData && sessionData.attendance_type === 'AI') {
          defaultAiEnabled = true;
          console.log('ü§ñ Nova conversa criada com IA habilitada (configura√ß√£o da conex√£o)');
        } else {
          console.log('ü§ñ Nova conversa criada com atendimento humano (configura√ß√£o da conex√£o)');
        }
      } catch (error) {
        console.log('ü§ñ Erro ao buscar configura√ß√£o da conex√£o, usando padr√£o humano');
      }
      
      const { data: newContact, error: createError } = await supabase
        .from('contacts')
        .insert({
          phone: phoneNumber,
          name: phoneNumber,
          whatsapp_name: phoneNumber,
          ai_enabled: mode === 'ai' ? true : defaultAiEnabled,
          owner_id: req.user?.id,
          company_id: req.user?.company_id
        })
        .select()
        .single();
      
      if (createError) {
        console.error('‚ùå Erro ao criar contato:', createError);
        return res.status(500).json({ 
          ok: false, 
          error: 'Erro ao criar contato' 
        });
      }
      
      console.log('‚úÖ Contato criado com sucesso');
      return res.json({ 
        ok: true, 
        message: 'Modo de atendimento alterado com sucesso',
        contact: newContact
      });
    }
    
    // Atualizar o contato existente
    const { error: updateError } = await supabase
      .from('contacts')
      .update({ ai_enabled: mode === 'ai' })
      .eq('id', contactData.id);
    
    if (updateError) {
      console.error('‚ùå Erro ao atualizar contato:', updateError);
      return res.status(500).json({ 
        ok: false, 
        error: 'Erro ao atualizar contato' 
      });
    }
    
    console.log(`‚úÖ Modo de atendimento alterado para ${mode} no contato ${contactData.id}`);
    
    res.json({ 
      ok: true, 
      message: 'Modo de atendimento alterado com sucesso',
      contact: { ...contactData, ai_enabled: mode === 'ai' }
    });
    
  } catch (error) {
    console.error('‚ùå Erro ao alterar modo de atendimento:', error);
    res.status(500).json({ 
      ok: false, 
      error: 'Erro interno do servidor' 
    });
  }
});

// Mark all client messages as read for a conversation
app.post('/api/baileys-simple/atendimentos/:atendimentoId/read', async (req, res) => {
  try {
    const { atendimentoId } = req.params;
    const { connectionId } = req.body || {};
    const { error } = await supabase
      .from('whatsapp_mensagens')
      .update({ lida: true })
      .eq('connection_id', connectionId)
      .eq('remetente', 'CLIENTE')
      .eq('lida', false);

    if (error) return res.status(500).json({ success: false, error: error.message });
    if (connectionId) {
      io.to(connectionId).emit('conversation:read', { connectionId, conversationId: atendimentoId });
    }
    return res.json({ success: true });
  } catch (e) {
    return res.status(500).json({ success: false, error: 'Erro ao marcar como lido' });
  }
});

// Registrar contato WhatsApp na tabela contacts
app.post('/api/baileys-simple/register-contact', async (req, res) => {
  try {
    const { phone, name, owner_id } = req.body;
    
    if (!phone || !owner_id) {
      return res.status(400).json({ 
        success: false, 
        error: 'Phone e owner_id s√£o obrigat√≥rios' 
      });
    }

    console.log('üì± Registrando contato WhatsApp:', { phone, name, owner_id });

    // Verificar se o contato j√° existe
    const { data: existingContact, error: searchError } = await supabase
      .from('contacts')
      .select('*')
      .eq('phone', phone)
      .eq('owner_id', owner_id)
      .single();

    if (searchError && searchError.code !== 'PGRST116') {
      throw searchError;
    }

    if (existingContact) {
      // Atualizar contato existente
      console.log('üîÑ Atualizando contato existente:', existingContact.id);
      
      const { data: updatedContact, error: updateError } = await supabase
        .from('contacts')
        .update({
          name: name || existingContact.name,
          last_contact_at: new Date().toISOString(),
          whatsapp_opted: true,
          updated_at: new Date().toISOString()
        })
        .eq('id', existingContact.id)
        .select()
        .single();

      if (updateError) throw updateError;

      console.log('‚úÖ Contato atualizado:', updatedContact.id);
      return res.json({ 
        success: true, 
        contact: updatedContact, 
        action: 'updated' 
      });
    } else {
      // Criar novo contato
      console.log('‚ûï Criando novo contato');
      
      const { data: newContact, error: insertError } = await supabase
        .from('contacts')
        .insert({
          phone: phone,
          name: name || phone, // Usar telefone como nome se n√£o fornecido
          owner_id: owner_id,
          status: 'active',
          whatsapp_opted: true,
          last_contact_at: new Date().toISOString(),
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        })
        .select()
        .single();

      if (insertError) throw insertError;

      console.log('‚úÖ Novo contato criado:', newContact.id);
      return res.json({ 
        success: true, 
        contact: newContact, 
        action: 'created' 
      });
    }
  } catch (error) {
    console.error('‚ùå Erro ao registrar contato WhatsApp:', error);
    return res.status(500).json({ 
      success: false, 
      error: error.message 
    });
  }
});

// Atualizar nome do contato
app.put('/api/baileys-simple/contacts/:contactId', async (req, res) => {
  try {
    const { contactId } = req.params;
    const { name, owner_id } = req.body;
    
    if (!name || !owner_id) {
      return res.status(400).json({ 
        success: false, 
        error: 'Nome e owner_id s√£o obrigat√≥rios' 
      });
    }

    console.log('üìù Atualizando nome do contato:', { contactId, name, owner_id });

    // Atualizar contato na tabela contacts
    const { data: updatedContact, error: updateError } = await supabase
      .from('contacts')
      .update({
        name: name,
        updated_at: new Date().toISOString()
      })
      .eq('id', contactId)
      .eq('owner_id', owner_id)
      .select()
      .single();

    if (updateError) {
      if (updateError.code === 'PGRST116') {
        return res.status(404).json({ 
          success: false, 
          error: 'Contato n√£o encontrado' 
        });
      }
      throw updateError;
    }

    // Atualizar nome nas conversas do WhatsApp
    const { error: convUpdateError } = await supabase
      .from('whatsapp_conversations')
      .update({
        nome_cliente: name,
        updated_at: new Date().toISOString()
      })
      .eq('phone', updatedContact.phone)
      .eq('owner_id', owner_id);

    if (convUpdateError) {
      console.warn('‚ö†Ô∏è Erro ao atualizar nome nas conversas:', convUpdateError);
    }

    console.log('‚úÖ Nome do contato atualizado:', updatedContact.id);
    return res.json({ 
      success: true, 
      contact: updatedContact 
    });

  } catch (error) {
    console.error('‚ùå Erro ao atualizar nome do contato:', error);
    return res.status(500).json({ 
      success: false, 
      error: error.message || 'Erro interno do servidor' 
    });
  }
});

// Abort connection
app.post('/api/baileys-simple/connections/:connectionId/abort', async (req, res) => {
  try {
    const { connectionId } = req.params;
    const userId = req.headers['x-user-id'] || req.body.user_id || '00000000-0000-0000-0000-000000000000';
    const connection = activeConnections.get(connectionId);
    
    if (!connection) {
      return res.status(404).json({
        success: false,
        error: 'Conex√£o n√£o encontrada'
      });
    }
    
    console.log(`üõë Abortando conex√£o ${connectionId} para usu√°rio ${userId}`);
    
    if (connection.sock) {
      connection.sock.logout();
    }
    
    // Marcar como desconectado no Supabase antes de remover
    await updateConnectionStatus(connectionId, 'disconnected', {}, userId);
    
    // Remover da mem√≥ria
    activeConnections.delete(connectionId);
    
    // Remover do Supabase
    await removeSessionFromSupabase(connectionId);
    
    // Emitir evento de remo√ß√£o para o frontend
    io.emit('connectionRemoved', { connectionId });
    
    res.json({
      success: true,
      message: 'Conex√£o abortada'
    });
  } catch (error) {
    console.error('Erro ao abortar conex√£o:', error);
    res.status(500).json({
      success: false,
      error: 'Erro ao abortar conex√£o'
    });
  }
});

// DELETE /api/baileys-simple/connections/:connectionId - Deletar conex√£o completamente
app.delete('/api/baileys-simple/connections/:connectionId', async (req, res) => {
  try {
    const { connectionId } = req.params;
    const userId = req.headers['x-user-id'] || req.body.user_id || '00000000-0000-0000-0000-000000000000';
    const connection = activeConnections.get(connectionId);
    
    console.log(`üóëÔ∏è Deletando conex√£o ${connectionId} para usu√°rio ${userId}`);
    
    // Se a conex√£o estiver ativa, desconectar primeiro
    if (connection && connection.sock) {
      console.log(`üîå Desconectando conex√£o ativa ${connectionId}`);
      connection.sock.logout();
    }
    
    // Marcar como desconectado no Supabase antes de remover
    await updateConnectionStatus(connectionId, 'disconnected', {}, userId);
    
    // Remover da mem√≥ria
    activeConnections.delete(connectionId);
    
    // Remover do Supabase
    await removeSessionFromSupabase(connectionId);
    
    // Emitir evento de remo√ß√£o para o frontend
    io.emit('connectionRemoved', { connectionId });
    
    console.log(`‚úÖ Conex√£o ${connectionId} deletada com sucesso`);
    
    res.json({
      success: true,
      message: 'Conex√£o deletada com sucesso'
    });
  } catch (error) {
    console.error('Erro ao deletar conex√£o:', error);
    res.status(500).json({
      success: false,
      error: 'Erro ao deletar conex√£o'
    });
  }
});

// Socket.IO events
io.on('connection', (socket) => {
  console.log('üîå Cliente conectado via Socket.IO');

  socket.on('join', (data) => {
    const { connectionId, conversationId, room } = data;
    const roomName = room || `${connectionId}-${conversationId}`;
    console.log(`üë§ ===== CLIENTE ENTRANDO NA SALA =====`);
    console.log(`üë§ Sala: ${roomName}`);
    console.log(`üë§ Dados recebidos:`, data);
    console.log(`üë§ Socket ID: ${socket.id}`);
    
    socket.join(roomName);
    
    // Listar salas do socket para debug
    console.log(`üë§ Salas do socket ap√≥s join:`, Array.from(socket.rooms));
    
    // Verificar se a sala foi criada corretamente
    const roomInfo = io.sockets.adapter.rooms.get(roomName);
    console.log(`üë§ Sala criada? ${!!roomInfo}, Clientes na sala: ${roomInfo ? roomInfo.size : 0}`);
  });

  // NEW: room for the *whole* connection (left pane updates)
  socket.on('joinConnection', ({ connectionId }) => {
    console.log(`üë• ===== CLIENTE ENTRANDO NA SALA DE CONEX√ÉO =====`);
    console.log(`üë• Connection ID: ${connectionId}`);
    console.log(`üë• Socket ID: ${socket.id}`);
    socket.join(connectionId);
    
    // Verificar se entrou na sala
    const roomInfo = io.sockets.adapter.rooms.get(connectionId);
    console.log(`üë• Sala de conex√£o criada? ${!!roomInfo}, Clientes: ${roomInfo ? roomInfo.size : 0}`);
    
    // Enviar mensagem de teste para confirmar conex√£o
    socket.emit('test-connection', { 
      message: 'Conex√£o estabelecida com sucesso!', 
      timestamp: new Date().toISOString() 
    });

    // Teste: enviar uma mensagem fake para testar o sistema
    setTimeout(() => {
      console.log('üß™ Enviando mensagem de teste para debug...');
      const testMessage = {
        id: `test_${Date.now()}`,
        message_id: `test_${Date.now()}`,
        chat_id: 'test-chat-id',
        conteudo: 'Mensagem de teste do servidor',
        message_type: 'TEXTO',
        remetente: 'CLIENTE',
        timestamp: new Date().toISOString(),
        lida: false,
        connection_id: connectionId,
        owner_id: 'test-owner',
        atendimento_id: `test_${Date.now()}`,
        status: 'AGUARDANDO'
      };
      
      // Emitir para a sala de conex√£o
      io.to(connectionId).emit('newMessage', testMessage);
      console.log('üß™ Mensagem de teste enviada para a sala:', connectionId);
    }, 3000);
  });

  socket.on('leave', (data) => {
    const { room } = data;
    console.log(`üëã ===== CLIENTE SAINDO DA SALA =====`);
    console.log(`üëã Sala: ${room}`);
    console.log(`üëã Socket ID: ${socket.id}`);
    
    socket.leave(room);
    
    // Verificar se saiu da sala
    const roomInfo = io.sockets.adapter.rooms.get(room);
    console.log(`üëã Sala ainda existe? ${!!roomInfo}, Clientes restantes: ${roomInfo ? roomInfo.size : 0}`);
  });

  socket.on('disconnect', () => {
    console.log('üîå Cliente desconectado do Socket.IO');
  });
});

// Fun√ß√µes auxiliares para Agente IA (escopo global)
async function generateAIResponse(userMessage, chatId, messageType = 'TEXTO', userId = null, mediaUrl = null) {
  try {
    console.log('ü§ñ ===== GERANDO RESPOSTA IA =====');
    console.log('ü§ñ Mensagem do usu√°rio:', userMessage);
    console.log('ü§ñ Chat ID:', chatId);
    console.log('ü§ñ Tipo de mensagem:', messageType);
    console.log('ü§ñ User ID:', userId);
    console.log('ü§ñ Media URL:', mediaUrl);
    
    if (!userMessage || userMessage.trim() === '') {
      console.log('ü§ñ Mensagem vazia, retornando resposta padr√£o');
      return 'Ol√°! Como posso ajud√°-lo hoje?';
    }

    // Buscar hist√≥rico de conversa (√∫ltimas 30 mensagens)
    console.log('ü§ñ Buscando hist√≥rico de conversa...');
    let conversationHistory = [];
    try {
      const { data: historyData, error: historyError } = await supabaseAdmin
        .from('whatsapp_mensagens')
        .select('conteudo, remetente, timestamp, message_type')
        .eq('chat_id', chatId)
        .eq('owner_id', userId)
        .order('timestamp', { ascending: false })
        .limit(30);

      if (!historyError && historyData) {
        conversationHistory = historyData.reverse(); // Ordenar cronologicamente
        console.log('ü§ñ Hist√≥rico encontrado:', conversationHistory.length, 'mensagens');
      } else {
        console.log('ü§ñ Erro ao buscar hist√≥rico:', historyError?.message);
      }
        } catch (error) {
      console.log('ü§ñ Erro ao buscar hist√≥rico:', error.message);
    }

    // Buscar configura√ß√£o da IA para o usu√°rio
    let aiConfig = null;
    if (userId) {
      try {
        console.log('ü§ñ Buscando configura√ß√£o da IA para o usu√°rio:', userId);
        console.log('ü§ñ Supabase URL:', process.env.SUPABASE_URL ? 'Configurada' : 'N√£o configurada');
        console.log('ü§ñ Supabase Key:', process.env.SUPABASE_SERVICE_ROLE_KEY ? 'Configurada' : 'N√£o configurada');
        
        // Buscar configura√ß√£o ativa primeiro (usando supabaseAdmin para bypass de RLS)
        console.log('ü§ñ Buscando configura√ß√£o com userId:', userId);
        let { data: configData, error: configError } = await supabaseAdmin
          .from('ai_agent_configs')
          .select('*')
          .eq('owner_id', userId)
          .eq('is_active', true)
          .limit(1);
        
        console.log('ü§ñ Resultado da busca ativa:', { 
          data: configData?.length || 0, 
          error: configError?.message || 'null' 
        });

        // Se n√£o encontrou configura√ß√£o ativa, buscar qualquer configura√ß√£o do usu√°rio
        if (!configData || configData.length === 0) {
          console.log('ü§ñ Nenhuma configura√ß√£o ativa encontrada, buscando qualquer configura√ß√£o...');
          const { data: anyConfig, error: anyError } = await supabaseAdmin
            .from('ai_agent_configs')
            .select('*')
            .eq('owner_id', userId)
            .limit(1);
          
          if (!anyError && anyConfig && anyConfig.length > 0) {
            configData = anyConfig;
            configError = null;
            console.log('ü§ñ Configura√ß√£o encontrada (n√£o ativa), ativando...');
            
            // Parse knowledge_base se for string
            if (typeof configData[0].knowledge_base === 'string') {
              try {
                configData[0].knowledge_base = JSON.parse(configData[0].knowledge_base);
              } catch (e) {
                console.log('‚ö†Ô∏è Erro ao fazer parse do knowledge_base:', e.message);
                configData[0].knowledge_base = { files: [], websites: [], qa: [] };
              }
            }
            
            // Ativar a configura√ß√£o encontrada
            await supabaseAdmin
              .from('ai_agent_configs')
              .update({ is_active: true })
              .eq('id', anyConfig[0].id);
          }
        }

        console.log('ü§ñ Resultado da busca - configData:', configData ? configData.length : 'null');
        console.log('ü§ñ Resultado da busca - configError:', configError ? configError.message : 'null');

        if (configError) {
          console.log('‚ö†Ô∏è Erro ao buscar configura√ß√£o da IA:', configError.message);
          
          // Se n√£o existe configura√ß√£o, criar uma padr√£o
          if (configError.code === 'PGRST116') {
            console.log('ü§ñ Criando configura√ß√£o padr√£o da IA...');
            const defaultConfig = {
              owner_id: userId,
              name: 'Assistente Virtual VB',
              function: 'Atendimento ao cliente via WhatsApp',
              personality: 'Profissional, prestativo e eficiente. Sempre ajude o cliente com informa√ß√µes sobre produtos e servi√ßos.',
              status: 'active',
              response_style: 'friendly',
              language: 'pt-BR',
              max_response_length: 500,
              company_context: 'Empresa de tecnologia e solu√ß√µes digitais',
              company_description: 'Oferecemos servi√ßos de desenvolvimento de software, consultoria em tecnologia e solu√ß√µes digitais personalizadas.',
              api_key: null,
              selected_model: 'gpt-4o-mini',
              is_connected: false,
              is_active: true,
              knowledge_base: {
                files: [],
                websites: [],
                qa: [
                  {
                    question: 'Quais servi√ßos voc√™s oferecem?',
                    answer: 'Oferecemos desenvolvimento de software, consultoria em tecnologia, cria√ß√£o de sites e aplicativos, e solu√ß√µes digitais personalizadas.'
                  },
                  {
                    question: 'Como posso entrar em contato?',
                    answer: 'Voc√™ pode entrar em contato atrav√©s do nosso WhatsApp, email ou telefone. Nossa equipe est√° dispon√≠vel de segunda a sexta, das 8h √†s 18h.'
                  },
                  {
                    question: 'Qual o prazo para desenvolvimento?',
                    answer: 'O prazo varia conforme a complexidade do projeto. Projetos simples podem ser entregues em 2-4 semanas, enquanto projetos mais complexos podem levar 2-6 meses.'
                  }
                ]
              }
            };
            
            const { data: newConfig, error: insertError } = await supabaseAdmin
              .from('ai_agent_configs')
              .insert(defaultConfig)
              .select()
              .single();
            
            if (insertError) {
              console.log('‚ö†Ô∏è Erro ao criar configura√ß√£o padr√£o:', insertError.message);
            } else {
              aiConfig = newConfig;
              console.log('‚úÖ Configura√ß√£o padr√£o criada com sucesso!');
            }
          }
        } else if (configData && configData.length > 0) {
          aiConfig = configData[0]; // Pegar o primeiro elemento do array
          
          // Parse knowledge_base se for string
          if (typeof aiConfig.knowledge_base === 'string') {
            try {
              aiConfig.knowledge_base = JSON.parse(aiConfig.knowledge_base);
            } catch (e) {
              console.log('‚ö†Ô∏è Erro ao fazer parse do knowledge_base:', e.message);
              aiConfig.knowledge_base = { files: [], websites: [], qa: [] };
            }
          }
          
          console.log('‚úÖ Configura√ß√£o da IA encontrada:', {
            name: aiConfig.name,
            model: aiConfig.selected_model || aiConfig.model,
            personality: aiConfig.personality,
            api_key: aiConfig.api_key ? 'Configurada' : 'N√£o configurada',
            knowledge_base: aiConfig.knowledge_base?.qa?.length || 0,
            is_active: aiConfig.is_active,
            status: aiConfig.status
          });
          console.log('ü§ñ Configura√ß√£o completa:', JSON.stringify(aiConfig, null, 2));
        } else {
          console.log('‚ö†Ô∏è Nenhuma configura√ß√£o ativa encontrada para o usu√°rio');
          console.log('ü§ñ Buscando configura√ß√µes inativas...');
          
          // Buscar configura√ß√µes inativas para debug
          const { data: inactiveConfigs } = await supabaseAdmin
            .from('ai_agent_configs')
            .select('*')
            .eq('owner_id', userId);
          
          console.log('ü§ñ Configura√ß√µes encontradas (ativas e inativas):', inactiveConfigs?.length || 0);
          if (inactiveConfigs && inactiveConfigs.length > 0) {
            inactiveConfigs.forEach((config, index) => {
              console.log(`ü§ñ Config ${index + 1}:`, {
                name: config.name,
                is_active: config.is_active,
                status: config.status,
                api_key: config.api_key ? 'Configurada' : 'N√£o configurada'
              });
            });
          }
        }
      } catch (error) {
        console.log('‚ö†Ô∏è Erro ao buscar configura√ß√£o da IA:', error.message);
      }
    }

    // Analisar conte√∫do de m√≠dia se dispon√≠vel
    let mediaContent = null;
    if (mediaUrl && (messageType === 'IMAGEM' || messageType === 'AUDIO')) {
      console.log('ü§ñ ===== AN√ÅLISE DE M√çDIA =====');
      console.log('ü§ñ Tipo de mensagem:', messageType);
      console.log('ü§ñ URL da m√≠dia:', mediaUrl);
      console.log('ü§ñ Tem configura√ß√£o AI:', !!aiConfig);
      console.log('ü§ñ Tem API key:', !!aiConfig?.api_key);
      
      try {
        mediaContent = await analyzeMediaContent(messageType, mediaUrl, aiConfig);
        console.log('ü§ñ Conte√∫do da m√≠dia analisado:', mediaContent);
      } catch (mediaError) {
        console.error('‚ùå Erro na an√°lise de m√≠dia:', mediaError);
        mediaContent = null;
      }
      console.log('ü§ñ ===========================');
    }

    // Se n√£o tem configura√ß√£o v√°lida ou API key, usar resposta simples
    if (!aiConfig || !aiConfig.api_key || aiConfig.api_key === 'sk-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx') {
      console.log('ü§ñ Usando sistema de respostas simples (sem OpenAI)');
      return generateSimpleResponse(userMessage, messageType, aiConfig);
    }

    // Usar OpenAI para gerar resposta contextual
    console.log('ü§ñ Gerando resposta com OpenAI...');
    return await generateOpenAIResponse(userMessage, messageType, aiConfig, mediaContent, conversationHistory);
    
  } catch (error) {
    console.error('‚ùå Erro ao gerar resposta IA:', error);
    return generateSimpleResponse(userMessage, messageType, aiConfig);
  }
}

// Fun√ß√£o para gerar resposta simples (fallback)
function generateSimpleResponse(userMessage, messageType, aiConfig = null) {
  const lowerMessage = userMessage.toLowerCase().trim();
  
  console.log('ü§ñ ===== GERANDO RESPOSTA SIMPLES =====');
  console.log('ü§ñ Mensagem original:', userMessage);
  console.log('ü§ñ Mensagem lowercase:', lowerMessage);
  console.log('ü§ñ Tipo de mensagem:', messageType);
  console.log('ü§ñ Tem configura√ß√£o AI:', !!aiConfig);
  console.log('ü§ñ =====================================');
  
  // Respostas espec√≠ficas para diferentes tipos de mensagem
  if (messageType === 'AUDIO') {
    return 'Recebi sua mensagem de √°udio! Infelizmente n√£o posso ouvir o conte√∫do, mas posso ajud√°-lo com informa√ß√µes sobre nossos produtos e servi√ßos. O que gostaria de saber?';
  }
  
  if (messageType === 'IMAGEM') {
    return 'Recebi sua imagem! Infelizmente n√£o posso ver o conte√∫do, mas posso ajud√°-lo com informa√ß√µes sobre nossos produtos e servi√ßos. O que gostaria de saber?';
  }
  
  if (messageType === 'VIDEO') {
    return 'Recebi seu v√≠deo! Infelizmente n√£o posso ver o conte√∫do, mas posso ajud√°-lo com informa√ß√µes sobre nossos produtos e servi√ßos. O que gostaria de saber?';
  }

  // Usar base de conhecimento se dispon√≠vel
  if (aiConfig && aiConfig.knowledge_base && aiConfig.knowledge_base.qa) {
    console.log('ü§ñ Base de conhecimento dispon√≠vel:', aiConfig.knowledge_base.qa.length, 'perguntas');
    
    for (const qa of aiConfig.knowledge_base.qa) {
      console.log('ü§ñ Verificando pergunta:', qa.question);
      
      // Busca mais flex√≠vel - verificar se a mensagem cont√©m palavras-chave da pergunta
      const questionLower = qa.question.toLowerCase();
      const messageLower = lowerMessage.toLowerCase();
      
      // Verificar correspond√™ncia direta (mais restritiva)
      if (messageLower === questionLower || 
          messageLower.includes(questionLower) && questionLower.length > 10 ||
          questionLower.includes(messageLower) && messageLower.length > 10) {
        console.log('ü§ñ ‚úÖ Correspond√™ncia direta encontrada:', qa.question);
        return qa.answer;
      }
      
      // Verificar palavras-chave espec√≠ficas (mais restritivas)
      const specificKeywords = {
        'empresa': ['empresa', 'companhia', 'corpora√ß√£o'],
        'servi√ßo': ['servi√ßo', 'como funciona', 'funciona'],
        'valor': ['valor', 'pre√ßo', 'custo', 'quanto'],
        'onde': ['onde', 'localiza√ß√£o', 'endere√ßo', 'ficam'],
        'contato': ['contato', 'telefone', 'email', 'falar']
      };
      
      // Verificar se a mensagem e pergunta compartilham contexto espec√≠fico
      for (const [context, keywords] of Object.entries(specificKeywords)) {
        const messageHasContext = keywords.some(keyword => messageLower.includes(keyword));
        const questionHasContext = keywords.some(keyword => questionLower.includes(keyword));
        
        if (messageHasContext && questionHasContext) {
          console.log('ü§ñ ‚úÖ Correspond√™ncia por contexto espec√≠fico encontrada:', qa.question, 'Contexto:', context);
          return qa.answer;
        }
      }
      
      // Verificar palavras em comum (mais restritivo)
      const questionWords = questionLower.split(' ').filter(word => word.length > 3);
      const messageWords = messageLower.split(' ').filter(word => word.length > 3);
      
      const commonWords = questionWords.filter(word => 
        messageWords.some(msgWord => 
          msgWord === word || // Correspond√™ncia exata
          (msgWord.includes(word) && word.length > 4) || // Inclus√£o apenas para palavras longas
          (word.includes(msgWord) && msgWord.length > 4)
        )
      );
      
      // Aumentar o threshold para correspond√™ncia
      if (commonWords.length >= 2 && questionWords.length <= 6) {
        console.log('ü§ñ ‚úÖ Correspond√™ncia por palavras comuns encontrada:', qa.question, 'Palavras:', commonWords);
        return qa.answer;
      }
    }
  }

  // Respostas baseadas em palavras-chave mais espec√≠ficas
        const responses = {
    'quem ta falando': 'Ol√°! Sou o assistente virtual da empresa. Estou aqui para ajudar com informa√ß√µes sobre nossos produtos e servi√ßos. Como posso atend√™-lo?',
    'quem ta falando?': 'Ol√°! Sou o assistente virtual da empresa. Estou aqui para ajudar com informa√ß√µes sobre nossos produtos e servi√ßos. Como posso atend√™-lo?',
    'quem √©': 'Ol√°! Sou o assistente virtual da empresa. Estou aqui para ajudar com informa√ß√µes sobre nossos produtos e servi√ßos. Como posso atend√™-lo?',
    'fechou': 'Entendi! Se precisar de mais alguma coisa, estou aqui para ajudar.',
    'fechow': 'Entendi! Se precisar de mais alguma coisa, estou aqui para ajudar.',
    'maninho': 'Ol√°! Como posso ajud√°-lo hoje?',
    'irm√£o': 'Ol√°! Como posso ajud√°-lo hoje?',
    'com quem falo': 'Ol√°! Sou o assistente virtual da empresa. Estou aqui para ajudar com informa√ß√µes sobre nossos produtos e servi√ßos. Como posso atend√™-lo?',
    'quem est√° falando': 'Ol√°! Sou o assistente virtual da empresa. Estou aqui para ajudar com informa√ß√µes sobre nossos produtos e servi√ßos. Como posso atend√™-lo?',
    'quem √© voc√™': 'Ol√°! Sou o assistente virtual da empresa. Estou aqui para ajudar com informa√ß√µes sobre nossos produtos e servi√ßos. Como posso atend√™-lo?',
    'como se chama': 'Ol√°! Sou o assistente virtual da empresa. Estou aqui para ajudar com informa√ß√µes sobre nossos produtos e servi√ßos. Como posso atend√™-lo?',
    'qual seu nome': 'Ol√°! Sou o assistente virtual da empresa. Estou aqui para ajudar com informa√ß√µes sobre nossos produtos e servi√ßos. Como posso atend√™-lo?',
    'qual empresa': 'Somos uma empresa de tecnologia e solu√ß√µes digitais. Oferecemos desenvolvimento de software, consultoria em tecnologia e solu√ß√µes personalizadas.',
    'servi√ßos': 'Oferecemos desenvolvimento de software, consultoria em tecnologia, cria√ß√£o de sites e aplicativos, e solu√ß√µes digitais personalizadas. Qual servi√ßo te interessa?',
          'oi': 'Ol√°! Como posso ajud√°-lo hoje?',
          'ol√°': 'Ol√°! Como posso ajud√°-lo hoje?',
          'oi!': 'Ol√°! Como posso ajud√°-lo hoje?',
          'ol√°!': 'Ol√°! Como posso ajud√°-lo hoje?',
          'oiii': 'Ol√°! Como posso ajud√°-lo hoje?',
          'oiiii': 'Ol√°! Como posso ajud√°-lo hoje?',
          'oiiiii': 'Ol√°! Como posso ajud√°-lo hoje?',
          'ooopa': 'Ol√°! Como posso ajud√°-lo hoje?',
          'tudo bem': 'Tudo bem sim! Como posso ajud√°-lo hoje?',
          'tudo bem?': 'Tudo bem sim! Como posso ajud√°-lo hoje?',
    'ajuda': 'Claro! Estou aqui para ajudar. Posso fornecer informa√ß√µes sobre nossos produtos, servi√ßos, pre√ßos e muito mais. O que voc√™ precisa?',
    'pre√ßo': 'Gostaria de saber mais sobre nossos pre√ßos. Posso fornecer informa√ß√µes gerais sobre nossos produtos e servi√ßos. Qual produto ou servi√ßo te interessa?',
    'produto': 'Temos v√°rios produtos dispon√≠veis. Posso fornecer informa√ß√µes sobre nossos produtos e servi√ßos. Qual √°rea te interessa mais?',
    'servi√ßo': 'Temos v√°rios servi√ßos dispon√≠veis. Posso fornecer informa√ß√µes sobre nossos produtos e servi√ßos. Qual servi√ßo te interessa mais?',
    'contato': 'Posso te ajudar a entrar em contato com nossa equipe. Para informa√ß√µes mais espec√≠ficas, posso conectar voc√™ com um de nossos especialistas. Qual √© o assunto?',
          'hello': 'Hello! How can I help you today?',
          'hi': 'Hi! How can I help you today?',
    'help': 'I\'m here to help! I can provide information about our products, services, pricing and more. What do you need?'
        };
        
  // Buscar por palavras-chave mais espec√≠ficas primeiro
        for (const [keyword, resp] of Object.entries(responses)) {
          if (lowerMessage.includes(keyword)) {
      return resp;
    }
  }
  
  // Resposta padr√£o mais informativa
  return 'Ol√°! Sou o assistente virtual. Posso ajud√°-lo com informa√ß√µes sobre nossos produtos e servi√ßos. O que gostaria de saber?';
}

// Fun√ß√£o para analisar conte√∫do de m√≠dia
async function analyzeMediaContent(messageType, mediaUrl, aiConfig) {
  if (!aiConfig || !aiConfig.api_key) {
    console.log('ü§ñ N√£o h√° configura√ß√£o de IA para an√°lise de m√≠dia');
    return null;
  }

  try {
    const OpenAI = require('openai');
    const openai = new OpenAI({
      apiKey: aiConfig.api_key
    });

    // Construir URL completa para m√≠dia
    let fullMediaUrl = mediaUrl;
    if (mediaUrl.startsWith('media:')) {
      const hash = mediaUrl.replace('media:', '');
      fullMediaUrl = `http://localhost:3001/api/media/${hash}`;
      console.log('ü§ñ Convertendo media:hash para URL:', { hash, fullUrl: fullMediaUrl });
    } else if (mediaUrl.startsWith('data:')) {
      // URL j√° √© base64, usar diretamente
      fullMediaUrl = mediaUrl;
      console.log('ü§ñ Usando URL base64 diretamente');
    }

    console.log('ü§ñ Analisando m√≠dia:', { messageType, originalUrl: mediaUrl, fullUrl: fullMediaUrl });

    if (messageType === 'IMAGEM' && fullMediaUrl) {
      console.log('ü§ñ Analisando imagem com OpenAI Vision...');
      
      try {
        const response = await openai.chat.completions.create({
          model: 'gpt-4o-mini',
          messages: [
            {
              role: 'user',
              content: [
                {
                  type: 'text',
                  text: 'Descreva esta imagem em detalhes. O que voc√™ v√™? Identifique objetos, pessoas, texto, cores e contexto geral.'
                },
                {
                  type: 'image_url',
                  image_url: {
                    url: fullMediaUrl
                  }
                }
              ]
            }
          ],
          max_tokens: 500
        });

        const description = response.choices[0]?.message?.content;
        console.log('ü§ñ Descri√ß√£o da imagem gerada:', description);
        return description;
      } catch (visionError) {
        console.error('‚ùå Erro na an√°lise de imagem:', visionError.message);
        return 'Imagem recebida, mas n√£o foi poss√≠vel analisar o conte√∫do.';
      }
    }

    if (messageType === 'AUDIO' && fullMediaUrl) {
      console.log('ü§ñ Analisando √°udio com Whisper...');
      
      try {
        const audioResponse = await fetch(fullMediaUrl);
        if (audioResponse.ok) {
          const audioBuffer = await audioResponse.arrayBuffer();
          const audioFile = new File([audioBuffer], 'audio.ogg', { type: 'audio/ogg' });
          
          const transcription = await openai.audio.transcriptions.create({
            file: audioFile,
            model: 'whisper-1'
          });

          const transcript = transcription.text;
          console.log('ü§ñ Transcri√ß√£o do √°udio:', transcript);
          return transcript;
        } else {
          console.error('‚ùå Erro ao baixar √°udio:', audioResponse.status);
          return '√Åudio recebido, mas n√£o foi poss√≠vel processar o conte√∫do.';
        }
      } catch (audioError) {
        console.error('‚ùå Erro na transcri√ß√£o de √°udio:', audioError.message);
        return '√Åudio recebido, mas n√£o foi poss√≠vel transcrever o conte√∫do.';
      }
    }

    return null;
  } catch (error) {
    console.error('‚ùå Erro geral ao analisar m√≠dia:', error.message);
    return null;
  }
}

// Fun√ß√£o para gerar resposta com OpenAI
async function generateOpenAIResponse(userMessage, messageType, aiConfig, mediaContent = null, conversationHistory = []) {
  try {
    const OpenAI = require('openai');
    const openai = new OpenAI({
      apiKey: aiConfig.api_key
    });

    // Construir prompt baseado na configura√ß√£o (igual √† p√°gina de teste)
    let systemPrompt = 'Voc√™ √© ' + (aiConfig.name || 'Assistente Virtual VB') + ', um assistente virtual especializado em ' + (aiConfig.function || 'atendimento ao cliente') + '.\n\n' +
      'PERSONALIDADE E COMPORTAMENTO:\n' +
      (aiConfig.personality || 'Profissional, prestativo e eficiente') + '\n\n'

      'CONFIGURA√á√ïES DE RESPOSTA:\n' +
      '- Estilo: ' + (aiConfig.response_style || 'friendly') + '\n' +
      '- Idioma: ' + (aiConfig.language === 'pt-BR' ? 'Portugu√™s brasileiro' : aiConfig.language || 'Portugu√™s brasileiro') + '\n' +
      '- Tamanho m√°ximo: ' + (aiConfig.max_response_length || 500) + ' caracteres\n\n'

      'FUN√á√ÉO PRINCIPAL:\n' +
      (aiConfig.function || 'Atendimento ao cliente via WhatsApp') + '\n\n' +
      'STATUS DO AGENTE:\n' +
      '- Status: ' + (aiConfig.is_active ? 'Ativo e operacional' : 'Inativo') + '\n\n' +
      'CONFIGURA√á√ïES AVAN√áADAS:\n' +
      (aiConfig.tone ? '- Tom espec√≠fico: ' + aiConfig.tone + '\n' : '') +
      (aiConfig.rules ? '- Regras espec√≠ficas: ' + aiConfig.rules + '\n' : '') +
      (aiConfig.company_context ? '- Contexto da empresa: ' + aiConfig.company_context + '\n' : '') +
      (aiConfig.sector ? '- Setor de atua√ß√£o: ' + aiConfig.sector + '\n' : '') +
      (aiConfig.company_description ? '- Descri√ß√£o da empresa: ' + aiConfig.company_description + '\n' : '') +

      'BASE DE CONHECIMENTO:\n' +
      (aiConfig.knowledge_base && aiConfig.knowledge_base.files && aiConfig.knowledge_base.files.length > 0 ? 
        'ARQUIVOS PROCESSADOS:\n' + 
        aiConfig.knowledge_base.files.map(file => '- ' + file.name + ' (' + file.type + '): ' + file.content).join('\n') + '\n\n' : '') +
      (aiConfig.knowledge_base && aiConfig.knowledge_base.websites && aiConfig.knowledge_base.websites.length > 0 ? 
        'WEBSITES ANALISADOS:\n' + 
        aiConfig.knowledge_base.websites.map(website => '- ' + website.title + ' (' + website.url + '): ' + website.content).join('\n') + '\n\n' : '') +
      (aiConfig.knowledge_base && aiConfig.knowledge_base.qa && aiConfig.knowledge_base.qa.length > 0 ? 
        'PERGUNTAS E RESPOSTAS:\n' + 
        aiConfig.knowledge_base.qa.map(qa => 'P: ' + qa.question + '\nR: ' + qa.answer).join('\n\n') + '\n\n' : '');

    // Adicionar contexto sobre tipo de mensagem com instru√ß√µes mais espec√≠ficas
    if (messageType === 'AUDIO') {
      if (mediaContent) {
        systemPrompt += '\n\nO usu√°rio enviou uma mensagem de √°udio que foi transcrita como: "' + mediaContent + '". Responda baseado no conte√∫do transcrito.';
      } else {
        systemPrompt += '\n\nO usu√°rio enviou uma mensagem de √°udio. Como voc√™ n√£o pode ouvir o √°udio, responda de forma √∫til perguntando sobre o que eles gostariam de saber ou oferecendo ajuda geral.';
      }
    } else if (messageType === 'IMAGEM') {
      if (mediaContent) {
        systemPrompt += '\n\nO usu√°rio enviou uma imagem que foi descrita como: "' + mediaContent + '". Responda baseado na descri√ß√£o da imagem.';
      } else {
        systemPrompt += '\n\nO usu√°rio enviou uma imagem. Como voc√™ n√£o pode ver a imagem, responda de forma √∫til perguntando sobre o que eles gostariam de saber sobre a imagem ou oferecendo ajuda geral.';
      }
    } else if (messageType === 'VIDEO') {
      systemPrompt += '\n\nO usu√°rio enviou um v√≠deo. Como voc√™ n√£o pode ver o v√≠deo, responda de forma √∫til perguntando sobre o que eles gostariam de saber sobre o v√≠deo ou oferecendo ajuda geral.';
    }

    // Adicionar regras espec√≠ficas se dispon√≠veis
    if (aiConfig.rules) {
      systemPrompt += '\n\nRegras importantes: ' + aiConfig.rules;
    }

    // Adicionar hist√≥rico de conversa se dispon√≠vel
    if (conversationHistory && conversationHistory.length > 0) {
      systemPrompt += '\n\n=== HIST√ìRICO DA CONVERSA ===';
      systemPrompt += '\nUse este hist√≥rico para entender o contexto da conversa:';
      conversationHistory.forEach((msg, index) => {
        const sender = msg.remetente === 'AI' ? 'Assistente' : 'Cliente';
        systemPrompt += '\n' + sender + ': ' + msg.conteudo;
      });
      systemPrompt += '\n=== FIM DO HIST√ìRICO ===';
    }

    // Instru√ß√µes finais (igual √† p√°gina de teste)
    systemPrompt += '\n\nINSTRU√á√ïES IMPORTANTES:';
    systemPrompt += '\n- Sempre responda em ' + (aiConfig.language === 'pt-BR' ? 'portugu√™s brasileiro' : 'o idioma selecionado');
    systemPrompt += '\n- Mantenha o estilo ' + (aiConfig.response_style || 'friendly');
    systemPrompt += '\n- Seja ' + (aiConfig.personality || 'Profissional, prestativo e eficiente');
    systemPrompt += '\n- Foque em ' + (aiConfig.function || 'Atendimento ao cliente via WhatsApp');
    systemPrompt += '\n- Use a base de conhecimento acima para responder com precis√£o';
    systemPrompt += '\n- Respostas devem ter no m√°ximo ' + (aiConfig.max_response_length || 500) + ' caracteres';
    systemPrompt += '\n- ' + (aiConfig.is_active ? 'Voc√™ est√° ativo e pronto para ajudar' : 'Voc√™ est√° em modo limitado');
    systemPrompt += '\n\nResponda de forma √∫til, profissional e alinhada com todas essas configura√ß√µes e base de conhecimento.';

    console.log('ü§ñ ===== PROMPT DO SISTEMA =====');
    console.log('ü§ñ', systemPrompt);
    console.log('ü§ñ ===== MENSAGEM DO USU√ÅRIO =====');
    console.log('ü§ñ', userMessage);
    if (mediaContent) {
      console.log('ü§ñ ===== CONTE√öDO DA M√çDIA =====');
      console.log('ü§ñ', mediaContent);
    }
    console.log('ü§ñ ================================');

    // Construir mensagens igual √† p√°gina de teste
    const messages = [
      {
        role: 'system',
        content: systemPrompt
      },
      ...conversationHistory.map(msg => ({
        role: msg.remetente === 'AI' ? 'assistant' : 'user',
        content: msg.conteudo
      })),
      {
        role: 'user',
        content: userMessage
      }
    ];

    const completion = await openai.chat.completions.create({
      model: aiConfig.selected_model || aiConfig.model || 'gpt-4o-mini',
      messages: messages,
      max_tokens: Math.min(aiConfig.max_response_length || 500, 2000),
      temperature: parseFloat(aiConfig.temperature) || 0.7
    });

    const response = completion.choices[0]?.message?.content || 'Ol√°! Como posso ajud√°-lo hoje?';
    console.log('ü§ñ Resposta da OpenAI:', response);
    
        return response;
    
      } catch (error) {
    console.error('‚ùå Erro na API da OpenAI:', error.message);
    console.log('ü§ñ Voltando para resposta simples...');
    return generateSimpleResponse(userMessage, messageType, aiConfig);
      }
    }

    async function sendAIResponse(connectionId, chatId, response, userId) {
      try {
        console.log('ü§ñ ===== ENVIANDO RESPOSTA IA =====');
        console.log('ü§ñ Connection ID:', connectionId);
        console.log('ü§ñ Chat ID:', chatId);
        console.log('ü§ñ Resposta:', response);
        console.log('ü§ñ User ID:', userId);
        
        // Verifica√ß√µes de seguran√ßa
        if (!response || response.trim() === '') {
          console.log('ü§ñ Resposta vazia, n√£o enviando');
          return;
        }
        
        if (!connectionId || !chatId || !userId) {
          console.log('ü§ñ ‚ö†Ô∏è Par√¢metros obrigat√≥rios ausentes, n√£o enviando');
          return;
        }
        
        // Verificar se a conex√£o existe
        const connection = activeConnections.get(connectionId);
        if (!connection) {
          console.log('ü§ñ ‚ö†Ô∏è Conex√£o n√£o encontrada, n√£o enviando');
          return;
        }
        
        // Verificar se a conex√£o est√° ativa
        if (!connection.sock || !connection.isConnected) {
          console.log('‚ùå Conex√£o n√£o est√° ativa para enviar mensagem');
      return;
    }
    
    console.log('ü§ñ Enviando mensagem via WhatsApp API...');
    console.log('ü§ñ Chat ID para envio:', chatId);
    console.log('ü§ñ Resposta a enviar:', response);
    
    // Enviar mensagem via WhatsApp usando Baileys
    const result = await connection.sock.sendMessage(chatId, {
      text: response
    });
    
    console.log('ü§ñ ‚úÖ Mensagem enviada via WhatsApp API com sucesso!');
    console.log('ü§ñ Resultado do envio:', result);
    console.log('ü§ñ WhatsApp Message ID:', result.key?.id);
    
    // Criar mensagem de resposta da IA para salvar no banco
        const aiMessage = {
      message_id: result.key.id || `ai_${Date.now()}`,
          chat_id: chatId,
          conteudo: response,
          message_type: 'TEXTO',
          remetente: 'AI',
          timestamp: new Date().toISOString(),
      lida: true, // Mensagens da IA s√£o consideradas lidas
          connection_id: connectionId,
          owner_id: userId,
          atendimento_id: `ai_${Date.now()}`,
      status: 'AI',
      message_id: result.key.id
        };
        
        console.log('ü§ñ Mensagem IA criada:', aiMessage);
        
    // Salvar no banco e obter o ID gerado
    const { data: savedMessage, error: insertError } = await supabase
          .from('whatsapp_mensagens')
      .insert(aiMessage)
      .select()
      .single();
        
        if (insertError) {
          console.error('‚ùå Erro ao salvar resposta IA:', insertError);
      // Mesmo com erro no banco, a mensagem j√° foi enviada via WhatsApp
    } else {
      console.log('ü§ñ Resposta IA salva no banco com sucesso!', savedMessage);
        }
        
        // Emitir para o frontend
        const roomName = `${connectionId}-${chatId}`;
        console.log('ü§ñ Emitindo para sala:', roomName);
        
        // Verificar se a sala existe
        const room = io.sockets.adapter.rooms.get(roomName);
        console.log('ü§ñ Clientes na sala:', room ? room.size : 0);
        
        // Criar objeto de mensagem para emitir
    const messageToEmit = savedMessage || aiMessage;
        
        console.log('ü§ñ Mensagem a ser emitida:', messageToEmit);
        
        io.to(roomName).emit('newMessage', messageToEmit);
        
        console.log('ü§ñ Resposta IA enviada para o frontend!');
        
        // Tamb√©m emitir para a sala de conex√£o para atualizar a lista
        const preview = messageToEmit.conteudo || '[Mensagem]';
        const conversationUpdate = {
          connectionId,
          conversationId: chatId,
          lastMessageAt: messageToEmit.timestamp,
          last_message: messageToEmit,
          preview,
          from: 'AI',
          unread_count_delta: 0,
          // Adicionar nome_cliente para o frontend
          nome_cliente: messageToEmit.wpp_name || `Contato ${messageToEmit.phone}`,
          numero_cliente: messageToEmit.phone
        };
        
        console.log('ü§ñ Conversation update:', conversationUpdate);
        
        // Verificar se h√° clientes na sala antes de emitir
        const aiRoomClients = io.sockets.adapter.rooms.get(connectionId);
        console.log('ü§ñ Clientes na sala de conex√£o:', aiRoomClients ? aiRoomClients.size : 0);
        console.log('ü§ñ IDs dos clientes na sala:', aiRoomClients ? Array.from(aiRoomClients) : []);
        
        io.to(connectionId).emit('conversation:updated', conversationUpdate);
        
        console.log('ü§ñ Conversation updated emitido!');
        
      } catch (error) {
        console.error('‚ùå Erro ao enviar resposta IA:', error);
  }
}

// Fun√ß√£o para processar m√≠dias e gerar URLs v√°lidas com Base64
async function processMediaMessage(msg, connectionId) {
  try {
    const connection = activeConnections.get(connectionId);
    if (!connection || !connection.sock) {
      console.log('‚ö†Ô∏è Conex√£o n√£o encontrada para processar m√≠dia');
      return null;
    }

    // Extrair informa√ß√µes da m√≠dia
    let mediaInfo = null;
    if (msg.message?.imageMessage) {
      const img = msg.message.imageMessage;
      mediaInfo = {
        type: 'image',
        mimetype: img.mimetype || 'image/jpeg',
        url: img.url || null,
        mediaKey: img.mediaKey || null,
        fileLength: img.fileLength || null,
        fileSha256: img.fileSha256 || null,
        directPath: img.directPath || null
      };
    } else if (msg.message?.videoMessage) {
      const vid = msg.message.videoMessage;
      mediaInfo = {
        type: 'video',
        mimetype: vid.mimetype || 'video/mp4',
        url: vid.url || null,
        mediaKey: vid.mediaKey || null,
        fileLength: vid.fileLength || null,
        fileSha256: vid.fileSha256 || null,
        directPath: vid.directPath || null,
        seconds: vid.seconds || 0
      };
    } else if (msg.message?.audioMessage) {
      const aud = msg.message.audioMessage;
      mediaInfo = {
        type: 'audio',
        mimetype: aud.mimetype || 'audio/ogg',
        url: aud.url || null,
        mediaKey: aud.mediaKey || null,
        fileLength: aud.fileLength || null,
        fileSha256: aud.fileSha256 || null,
        directPath: aud.directPath || null,
        seconds: aud.seconds || 0,
        ptt: aud.ptt || false
      };
    } else if (msg.message?.documentMessage) {
      const doc = msg.message.documentMessage;
      mediaInfo = {
        type: 'document',
        mimetype: doc.mimetype || 'application/octet-stream',
        url: doc.url || null,
        mediaKey: doc.mediaKey || null,
        fileLength: doc.fileLength || null,
        fileSha256: doc.fileSha256 || null,
        directPath: doc.directPath || null,
        fileName: doc.fileName || 'documento'
      };
    }

    if (!mediaInfo) {
      return null;
    }

    console.log('üìé Processando m√≠dia:', mediaInfo);

    // Tentar baixar a m√≠dia se n√£o tiver URL
    if (!mediaInfo.url && mediaInfo.mediaKey) {
      try {
        console.log('üìé Tentando baixar m√≠dia via Baileys...');
        
        // Usar o downloadMediaMessage importado globalmente
        const buffer = await downloadMediaMessage(msg, 'buffer', {}, { 
          logger: console 
        });
        
        if (buffer && buffer.length > 0) {
          // Converter para base64 para armazenamento
          const base64 = buffer.toString('base64');
          const dataUrl = `data:${mediaInfo.mimetype};base64,${base64}`;
          
          // Se a URL for muito longa (>10000 chars), usar apenas o hash como refer√™ncia
          if (dataUrl.length > 10000) {
            const hash = require('crypto')
              .createHash('md5')
              .update(base64)
              .digest('hex');
            mediaInfo.url = `media:${hash}`;
            mediaInfo.hash = hash;
            mediaInfo.mediaData = buffer; // Armazenar dados bin√°rios
            mediaInfo.mediaData = buffer; // Armazenar dados bin√°rios
            console.log('üìé M√≠dia muito grande, usando hash como refer√™ncia:', {
              size: buffer.length,
              type: mediaInfo.type,
              hash: hash
            });
          } else {
            mediaInfo.url = dataUrl;
            console.log('‚úÖ M√≠dia baixada e convertida para base64:', {
              size: buffer.length,
              type: mediaInfo.type,
              mime: mediaInfo.mimetype
            });
          }
        } else {
          console.log('‚ö†Ô∏è Buffer de m√≠dia vazio');
        }
      } catch (downloadError) {
        console.error('‚ùå Erro ao baixar m√≠dia:', downloadError);
        // Tentar usar a URL direta se dispon√≠vel
        if (mediaInfo.directPath) {
          mediaInfo.url = `https://mmg.whatsapp.net${mediaInfo.directPath}`;
          console.log('üîÑ Usando URL direta como fallback');
        }
      }
    } else if (mediaInfo.url && mediaInfo.url.includes('mmg.whatsapp.net')) {
      // Se j√° tem URL do WhatsApp, tentar baixar e converter para base64
      try {
        console.log('üìé Convertendo URL do WhatsApp para base64...');
        const response = await fetch(mediaInfo.url);
        if (response.ok) {
          const buffer = Buffer.from(await response.arrayBuffer());
          const base64 = buffer.toString('base64');
          const dataUrl = `data:${mediaInfo.mimetype};base64,${base64}`;
          
          // Se a URL for muito longa (>10000 chars), usar apenas o hash como refer√™ncia
          if (dataUrl.length > 10000) {
            const hash = require('crypto')
              .createHash('md5')
              .update(base64)
              .digest('hex');
            mediaInfo.url = `media:${hash}`;
            mediaInfo.hash = hash;
            mediaInfo.mediaData = buffer; // Armazenar dados bin√°rios
            console.log('üìé M√≠dia muito grande, usando hash como refer√™ncia:', {
              size: buffer.length,
              type: mediaInfo.type,
              hash: hash
            });
          } else {
            mediaInfo.url = dataUrl;
            console.log('‚úÖ URL convertida para base64:', {
              size: buffer.length,
              type: mediaInfo.type
            });
          }
        }
      } catch (fetchError) {
        console.error('‚ùå Erro ao converter URL para base64:', fetchError);
        // Manter a URL original
      }
    }

    return mediaInfo;
  } catch (error) {
    console.error('‚ùå Erro ao processar m√≠dia:', error);
    return null;
  }
}

// Fun√ß√£o para inicializar servidor
async function initializeServer() {
  try {
    // Usar porta fixa para evitar conflitos
    console.log(`üîç Usando porta: ${PORT}`);
    
    // Carregar sess√µes existentes do Supabase
    const existingSessions = await loadExistingSessions();
    
    // Reconectar sess√µes que estavam conectadas
    for (const session of existingSessions) {
      if (session.status === 'connected') {
        console.log(`üîÑ Reconectando sess√£o: ${session.connection_id} para owner_id: ${session.owner_id}`);
        try {
          await createWhatsAppConnection(session.connection_id, session.owner_id);
        } catch (error) {
          console.error(`‚ùå Erro ao reconectar ${session.connection_id}:`, error);
          // Remover sess√£o que n√£o conseguiu reconectar
          await removeSessionFromSupabase(session.connection_id);
        }
      }
    }
    
     // Iniciar servidor

    // Endpoint para extrair informa√ß√µes completas de um contato
    app.post('/api/contact/extract-info', async (req, res) => {
      try {
        const { chatId, connectionId } = req.body;
        
        if (!chatId || !connectionId) {
          return res.status(400).json({
            success: false,
            message: 'chatId e connectionId s√£o obrigat√≥rios'
          });
        }

        const connection = activeConnections.get(connectionId);
        if (!connection || !connection.sock) {
          return res.status(404).json({
            success: false,
            message: 'Conex√£o n√£o encontrada ou n√£o ativa'
          });
        }

        console.log('üîç [API] Extraindo informa√ß√µes completas para:', chatId);
        
        const extractor = new ContactInfoExtractor(connection.sock);
        const contactInfo = await extractor.extractFullContactInfo(chatId);
        
        res.json({
          success: true,
          data: contactInfo,
          message: 'Informa√ß√µes extra√≠das com sucesso'
        });
        
      } catch (error) {
        console.error('‚ùå [API] Erro ao extrair informa√ß√µes:', error);
        res.status(500).json({
          success: false,
          message: 'Erro interno do servidor',
          error: error.message
        });
      }
    });

    // Endpoint para sincronizar todos os contatos
    app.post('/api/contact/sync-all', async (req, res) => {
      try {
        const { connectionId, ownerId } = req.body;
        
        if (!connectionId || !ownerId) {
          return res.status(400).json({
            success: false,
            message: 'connectionId e ownerId s√£o obrigat√≥rios'
          });
        }

        const connection = activeConnections.get(connectionId);
        if (!connection || !connection.sock) {
          return res.status(404).json({
            success: false,
            message: 'Conex√£o n√£o encontrada ou n√£o ativa'
          });
        }

        console.log('üîÑ [SYNC-ALL] Iniciando sincroniza√ß√£o completa de contatos...');
        
        const extractor = new ContactInfoExtractor(connection.sock);
        const allContacts = await extractor.extractAllContactsInfo();
        
        let contactsSaved = 0;
        let messagesSaved = 0;
        const errors = [];

        // Salvar cada contato
        for (const contactInfo of allContacts) {
          try {
            // 1. Salvar na tabela contacts
            const contactData = await extractor.saveContactInfoToDatabase(contactInfo, ownerId);
            if (contactData) {
              const { error: contactError } = await supabaseAdmin
                .from('contacts')
                .upsert(contactData, { onConflict: 'whatsapp_jid,owner_id' });
              
              if (contactError) {
                console.error('‚ùå [SYNC-ALL] Erro ao salvar contato:', contactError);
                errors.push(`Contato ${contactInfo.chatId}: ${contactError.message}`);
              } else {
                contactsSaved++;
              }
            }

            // 2. Salvar na tabela whatsapp_mensagens
            const messageData = await extractor.saveToWhatsappMensagens(contactInfo, ownerId, connectionId);
            if (messageData) {
              const { error: messageError } = await supabaseAdmin
                .from('whatsapp_mensagens')
                .insert(messageData);
              
              if (messageError) {
                console.error('‚ùå [SYNC-ALL] Erro ao salvar mensagem:', messageError);
                errors.push(`Mensagem ${contactInfo.chatId}: ${messageError.message}`);
              } else {
                messagesSaved++;
              }
            }

          } catch (error) {
            console.error(`‚ùå [SYNC-ALL] Erro ao processar contato ${contactInfo.chatId}:`, error);
            errors.push(`Processamento ${contactInfo.chatId}: ${error.message}`);
          }
        }
        
        res.json({
          success: true,
          data: {
            totalContacts: allContacts.length,
            contactsSaved,
            messagesSaved,
            errors: errors.length,
            errorDetails: errors
          },
          message: `Sincroniza√ß√£o completa: ${contactsSaved} contatos e ${messagesSaved} mensagens salvos`
        });
        
      } catch (error) {
        console.error('‚ùå [SYNC-ALL] Erro na sincroniza√ß√£o:', error);
        res.status(500).json({
          success: false,
          message: 'Erro interno do servidor',
          error: error.message
        });
      }
    });

    // Endpoint para obter todos os grupos participantes
    app.get('/api/groups/all-participating', async (req, res) => {
      try {
        const { connectionId } = req.query;
        
        if (!connectionId) {
          return res.status(400).json({
            success: false,
            message: 'connectionId √© obrigat√≥rio'
          });
        }

        const connection = activeConnections.get(connectionId);
        if (!connection || !connection.sock) {
          return res.status(404).json({
            success: false,
            message: 'Conex√£o n√£o encontrada ou n√£o ativa'
          });
        }

        console.log('üîç [GROUPS-ALL] Buscando todos os grupos participantes...');
        
        const extractor = new ContactInfoExtractor(connection.sock);
        const groups = await extractor.fetchAllParticipatingGroups();
        
        res.json({
          success: true,
          data: groups,
          message: `Encontrados ${Object.keys(groups).length} grupos participantes`
        });
        
      } catch (error) {
        console.error('‚ùå [GROUPS-ALL] Erro ao buscar grupos:', error);
        res.status(500).json({
          success: false,
          message: 'Erro interno do servidor',
          error: error.message
        });
      }
    });

    // Endpoint para testar perfis de neg√≥cio espec√≠ficos
    app.post('/api/contact/test-business-profiles', async (req, res) => {
      try {
        const { connectionId, chatIds } = req.body;
        
        if (!connectionId || !chatIds || !Array.isArray(chatIds)) {
          return res.status(400).json({
            success: false,
            message: 'connectionId e chatIds (array) s√£o obrigat√≥rios'
          });
        }

        const connection = activeConnections.get(connectionId);
        if (!connection || !connection.sock) {
          return res.status(404).json({
            success: false,
            message: 'Conex√£o n√£o encontrada ou n√£o ativa'
          });
        }

        console.log('üîç [BUSINESS-TEST] Testando perfis de neg√≥cio para:', chatIds);
        
        const extractor = new ContactInfoExtractor(connection.sock);
        const results = [];

        for (const chatId of chatIds) {
          try {
            console.log(`üîç [BUSINESS-TEST] Testando ${chatId}...`);
            
            // Testar getBusinessProfile diretamente
            let directProfile = null;
            try {
              directProfile = await connection.sock.getBusinessProfile(chatId);
              console.log(`‚úÖ [BUSINESS-TEST] Perfil direto encontrado para ${chatId}`);
            } catch (error) {
              console.log(`‚ÑπÔ∏è [BUSINESS-TEST] Perfil direto n√£o dispon√≠vel para ${chatId}:`, error.message);
            }

            // Testar com o extrator
            const contactInfo = await extractor.extractFullContactInfo(chatId);
            
            results.push({
              chatId,
              directProfile,
              extractedInfo: {
                isBusiness: contactInfo.isBusiness,
                businessName: contactInfo.businessName,
                businessDescription: contactInfo.businessDescription,
                businessCategory: contactInfo.businessCategory,
                businessEmail: contactInfo.businessEmail,
                businessWebsite: contactInfo.businessWebsite,
                isVerified: contactInfo.isVerified,
                profilePicture: !!contactInfo.profilePicture,
                name: contactInfo.name
              }
            });

          } catch (error) {
            console.error(`‚ùå [BUSINESS-TEST] Erro ao processar ${chatId}:`, error);
            results.push({
              chatId,
              error: error.message,
              directProfile: null,
              extractedInfo: null
            });
          }
        }
        
        res.json({
          success: true,
          data: results,
          message: `Testados ${chatIds.length} contatos para perfis de neg√≥cio`
        });
        
      } catch (error) {
        console.error('‚ùå [BUSINESS-TEST] Erro no teste:', error);
        res.status(500).json({
          success: false,
          message: 'Erro interno do servidor',
          error: error.message
        });
      }
    });

    // Iniciar servidor com tratamento de erro
    server.listen(PORT, () => {
      console.log(`üöÄ WhatsApp Baileys Server rodando na porta ${PORT}`);
      console.log(`üì± API dispon√≠vel em http://localhost:${PORT}/api`);
      console.log(`üîó Teste: http://localhost:${PORT}/api/test`);
      console.log(`üìã Conex√µes ativas: ${activeConnections.size}`);
      console.log(`üîå Socket.IO ativo para tempo real`);
    });
    
    server.on('error', (error) => {
      if (error.code === 'EADDRINUSE') {
        console.log(`‚ö†Ô∏è Porta ${PORT} est√° em uso, tentando porta ${PORT + 1}`);
        PORT += 1;
        // Verificar se a nova porta √© v√°lida
        if (PORT > 65535) {
          console.error('‚ùå Nenhuma porta dispon√≠vel encontrada');
          process.exit(1);
        }
        server.listen(PORT);
      } else {
        console.error('‚ùå Erro no servidor:', error);
        process.exit(1);
      }
    });
  } catch (error) {
    console.error('‚ùå Erro ao inicializar servidor:', error);
    process.exit(1);
  }
}

// Fun√ß√£o para limpar sess√µes antigas (executa a cada hora)
async function cleanupOldSessions() {
  try {
    const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000).toISOString();
    
    const { error } = await supabase
      .from('whatsapp_sessions')
      .delete()
      .eq('status', 'disconnected')
      .lt('updated_at', oneHourAgo);
    
    if (error) {
      console.error('Erro ao limpar sess√µes antigas:', error);
    } else {
      console.log('üßπ Sess√µes antigas limpas com sucesso');
    }
  } catch (error) {
    console.error('Erro na limpeza de sess√µes:', error);
  }
}

// ===== API ENDPOINTS PARA CONTATOS =====

// Listar contatos
app.get('/api/contacts', async (req, res) => {
  try {
    const { data: contacts, error } = await supabase
      .from('contacts')
      .select('*')
      .order('created_at', { ascending: false });

    if (error) {
      return res.status(500).json({ success: false, error: error.message });
    }

    res.json({ success: true, data: contacts });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// Criar contato
app.post('/api/contacts', async (req, res) => {
  try {
    const contactData = req.body;
    
    // Validar dados obrigat√≥rios
    if (!contactData.name || !contactData.phone) {
      return res.status(400).json({ 
        success: false, 
        error: 'Nome e telefone s√£o obrigat√≥rios' 
      });
    }

    // Adicionar timestamps
    contactData.created_at = new Date().toISOString();
    contactData.updated_at = new Date().toISOString();
    contactData.last_contact_at = new Date().toISOString();

    const { data: newContact, error } = await supabase
      .from('contacts')
      .insert(contactData)
      .select()
      .single();

    if (error) {
      return res.status(500).json({ success: false, error: error.message });
    }

    res.json({ success: true, data: newContact });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// Atualizar contato
app.put('/api/contacts/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const contactData = req.body;
    
    // Adicionar timestamp de atualiza√ß√£o
    contactData.updated_at = new Date().toISOString();

    const { data: updatedContact, error } = await supabase
      .from('contacts')
      .update(contactData)
      .eq('id', id)
      .select()
      .single();

    if (error) {
      return res.status(500).json({ success: false, error: error.message });
    }

    res.json({ success: true, data: updatedContact });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// Deletar contato
app.delete('/api/contacts/:id', async (req, res) => {
  try {
    const { id } = req.params;

    const { error } = await supabase
      .from('contacts')
      .delete()
      .eq('id', id);

    if (error) {
      return res.status(500).json({ success: false, error: error.message });
    }

    res.json({ success: true, message: 'Contato deletado com sucesso' });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// Converter contato em lead
app.post('/api/contacts/:id/convert-to-lead', async (req, res) => {
  try {
    const { id } = req.params;
    const { pipeline, priority = 'medium' } = req.body;

    // Buscar contato
    const { data: contact, error: contactError } = await supabase
      .from('contacts')
      .select('*')
      .eq('id', id)
      .single();

    if (contactError || !contact) {
      return res.status(404).json({ success: false, error: 'Contato n√£o encontrado' });
    }

    // Criar lead
    const leadData = {
      name: contact.name,
      phone: contact.phone,
      email: contact.email,
      company: contact.company,
      status: 'new',
      pipeline: pipeline || 'Qualifica√ß√£o',
      source: 'WhatsApp',
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    };

    const { data: newLead, error: leadError } = await supabase
      .from('leads')
      .insert(leadData)
      .select()
      .single();

    if (leadError) {
      return res.status(500).json({ success: false, error: leadError.message });
    }

    // Atualizar status do contato para 'lead'
    const { error: updateError } = await supabase
      .from('contacts')
      .update({ 
        status: 'lead',
        pipeline: pipeline || 'Qualifica√ß√£o',
        updated_at: new Date().toISOString()
      })
      .eq('id', id);

    if (updateError) {
      console.error('Erro ao atualizar status do contato:', updateError);
    }

    res.json({ 
      success: true, 
      data: { 
        lead: newLead,
        message: 'Contato convertido em lead com sucesso'
      }
    });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// Endpoint para buscar foto de perfil do WhatsApp
app.get('/api/whatsapp-profile/:connectionId/profile-picture/:jid', async (req, res) => {
  try {
    const { connectionId, jid } = req.params;
    const { highRes = false } = req.query;
    
    console.log('üì∏ [PROFILE-PICTURE] Buscando foto de perfil:', { connectionId, jid, highRes });
    
    // Buscar conex√£o ativa
    const connection = activeConnections.get(connectionId);
    if (!connection || !connection.sock) {
      return res.status(404).json({ 
        success: false, 
        error: 'Conex√£o n√£o encontrada ou n√£o conectada' 
      });
    }
    
    const sock = connection.sock;
    
    try {
      let profilePictureUrl;
      
      if (highRes === 'true') {
        // Tentar alta resolu√ß√£o primeiro
        profilePictureUrl = await sock.profilePictureUrl(jid, 'image');
      } else {
        // Baixa resolu√ß√£o
        profilePictureUrl = await sock.profilePictureUrl(jid);
      }
      
      console.log('‚úÖ [PROFILE-PICTURE] Foto encontrada:', profilePictureUrl);
      
      res.json({
        success: true,
        data: {
          profilePictureUrl,
          jid,
          highRes: highRes === 'true'
        }
      });
      
    } catch (profileError) {
      console.log('‚ÑπÔ∏è [PROFILE-PICTURE] Erro ao buscar foto:', profileError.message);
      
      // Tentar baixa resolu√ß√£o se alta resolu√ß√£o falhou
      if (highRes === 'true') {
        try {
          const lowResUrl = await sock.profilePictureUrl(jid);
          console.log('‚úÖ [PROFILE-PICTURE] Foto de baixa resolu√ß√£o encontrada:', lowResUrl);
          
          res.json({
            success: true,
            data: {
              profilePictureUrl: lowResUrl,
              jid,
              highRes: false
            }
          });
          return;
        } catch (lowResError) {
          console.log('‚ÑπÔ∏è [PROFILE-PICTURE] Nenhuma foto encontrada:', lowResError.message);
        }
      }
      
      res.json({
        success: false,
        error: 'Foto de perfil n√£o encontrada',
        data: {
          profilePictureUrl: null,
          jid
        }
      });
    }
    
  } catch (error) {
    console.error('‚ùå [PROFILE-PICTURE] Erro geral:', error);
    res.status(500).json({ 
      success: false, 
      error: error.message 
    });
  }
});

// Endpoint para testar valida√ß√£o de JID
app.get('/api/baileys-simple/test-jid-validation', async (req, res) => {
  try {
    const { jid } = req.query;
    
    if (!jid) {
      return res.status(400).json({ error: 'JID √© obrigat√≥rio' });
    }
    
    console.log('üß™ [TEST-JID] Testando JID:', jid);
    
    // Simular a mesma l√≥gica de valida√ß√£o
    let cleanJid;
    if (jid.includes('@s.whatsapp.net') || jid.includes('@c.us') || jid.includes('@g.us')) {
      cleanJid = jid; // Usar JID original se j√° tem formato v√°lido
    } else {
      cleanJid = jid.replace(/[^\d@.]/g, ''); // Limpar apenas se necess√°rio
    }
    console.log('üß™ [TEST-JID] JID limpo:', cleanJid);
    
    let chatJid;
    
    if (/^\d+$/.test(cleanJid)) {
      chatJid = `${cleanJid}@s.whatsapp.net`;
    } else if (cleanJid.includes('@c.us')) {
      chatJid = cleanJid.replace('@c.us', '@s.whatsapp.net');
    } else if (cleanJid.includes('@g.us')) {
      chatJid = cleanJid; // Preservar grupos
    } else if (cleanJid.includes('@s.whatsapp.net')) {
      chatJid = cleanJid;
    } else {
      chatJid = `${cleanJid}@s.whatsapp.net`;
    }
    
    // Valida√ß√£o com padr√µes
    const jidPatterns = [
      /^(\d+)@s\.whatsapp\.net$/,
      /^(\d+)@c\.us$/,
      /^(\d+)@g\.us$/,
      /^(\d+)$/
    ];
    
    let jidMatch = null;
    let finalJid = chatJid;
    
    for (const pattern of jidPatterns) {
      const match = chatJid.match(pattern);
      if (match) {
        jidMatch = match;
        if (pattern.source === '^(\\d+)$') {
          finalJid = `${match[1]}@s.whatsapp.net`;
        } else if (pattern.source === '^(\\d+)@c\\.us$') {
          finalJid = `${match[1]}@s.whatsapp.net`;
        }
        break;
      }
    }
    
    const result = {
      original: jid,
      cleaned: cleanJid,
      processed: chatJid,
      final: finalJid,
      isValid: !!jidMatch,
      phoneNumber: jidMatch ? jidMatch[1] : null,
      patterns: jidPatterns.map(p => p.source)
    };
    
    console.log('üß™ [TEST-JID] Resultado:', result);
    
    res.json({
      success: true,
      result,
      message: jidMatch ? 'JID v√°lido' : 'JID inv√°lido'
    });
    
  } catch (error) {
    console.error('‚ùå [TEST-JID] Erro:', error);
    res.status(500).json({ error: error.message });
  }
});

// Endpoint para sincronizar nomes reais dos contatos
app.post('/api/baileys-simple/sync-contact-names', async (req, res) => {
  try {
    const { connectionId, userId } = req.body;
    
    if (!connectionId || !userId) {
      return res.status(400).json({ error: 'connectionId e userId s√£o obrigat√≥rios' });
    }
    
    console.log('üîÑ [SYNC-CONTACTS] Iniciando sincroniza√ß√£o de nomes para:', { connectionId, userId });
    
    // Buscar conex√£o ativa
    const connection = activeConnections.get(connectionId);
    if (!connection || !connection.sock) {
      return res.status(404).json({ error: 'Conex√£o n√£o encontrada ou n√£o conectada' });
    }
    
    // Buscar contatos existentes no banco
    const { data: existingContacts, error: contactsError } = await supabaseAdmin
      .from('contacts')
      .select('id, phone, whatsapp_jid, name_wpp, whatsapp_name')
      .eq('owner_id', userId)
      .not('whatsapp_jid', 'is', null);
    
    if (contactsError) {
      console.error('‚ùå [SYNC-CONTACTS] Erro ao buscar contatos:', contactsError);
      return res.status(500).json({ error: 'Erro ao buscar contatos' });
    }
    
    if (!existingContacts || existingContacts.length === 0) {
      return res.json({
        success: true,
        message: 'Nenhum contato encontrado para sincronizar',
        updated: 0
      });
    }
    
    console.log(`üîÑ [SYNC-CONTACTS] Encontrados ${existingContacts.length} contatos para sincronizar`);
    
    let updatedCount = 0;
    const results = [];
    
    // Processar cada contato
    for (const contact of existingContacts) {
      try {
        console.log(`üîç [SYNC-CONTACTS] Processando contato: ${contact.whatsapp_jid}`);
        
        // Buscar nome real
        const realName = await getRealContactName(contact.whatsapp_jid, connection.sock);
        
        if (realName && realName !== contact.name_wpp) {
          // Atualizar contato no banco
          const { error: updateError } = await supabaseAdmin
            .from('contacts')
            .update({
              name_wpp: realName,
              whatsapp_name: realName,
              updated_at: new Date().toISOString()
            })
            .eq('id', contact.id);
          
          if (updateError) {
            console.error(`‚ùå [SYNC-CONTACTS] Erro ao atualizar contato ${contact.id}:`, updateError);
            results.push({
              contactId: contact.id,
              jid: contact.whatsapp_jid,
              oldName: contact.name_wpp,
              newName: realName,
              success: false,
              error: updateError.message
            });
          } else {
            console.log(`‚úÖ [SYNC-CONTACTS] Contato atualizado: ${contact.name_wpp} ‚Üí ${realName}`);
            updatedCount++;
            results.push({
              contactId: contact.id,
              jid: contact.whatsapp_jid,
              oldName: contact.name_wpp,
              newName: realName,
              success: true
            });
          }
        } else {
          console.log(`‚ÑπÔ∏è [SYNC-CONTACTS] Nome n√£o alterado para: ${contact.whatsapp_jid}`);
          results.push({
            contactId: contact.id,
            jid: contact.whatsapp_jid,
            oldName: contact.name_wpp,
            newName: realName || contact.name_wpp,
            success: true,
            message: 'Nome n√£o alterado'
          });
        }
        
        // Pequeno delay para evitar rate limiting
        await new Promise(resolve => setTimeout(resolve, 100));
        
      } catch (contactError) {
        console.error(`‚ùå [SYNC-CONTACTS] Erro ao processar contato ${contact.whatsapp_jid}:`, contactError);
        results.push({
          contactId: contact.id,
          jid: contact.whatsapp_jid,
          oldName: contact.name_wpp,
          newName: null,
          success: false,
          error: contactError.message
        });
      }
    }
    
    console.log(`‚úÖ [SYNC-CONTACTS] Sincroniza√ß√£o conclu√≠da. ${updatedCount} contatos atualizados.`);
    
    res.json({
      success: true,
      message: `Sincroniza√ß√£o conclu√≠da. ${updatedCount} contatos atualizados.`,
      updated: updatedCount,
      total: existingContacts.length,
      results
    });
    
  } catch (error) {
    console.error('‚ùå [SYNC-CONTACTS] Erro geral:', error);
    res.status(500).json({ error: error.message });
  }
});

// Endpoint para testar envio de √°udio especificamente
app.post('/api/baileys-simple/test-audio-send', upload.single('audio'), async (req, res) => {
  try {
    const { connectionId, jid } = req.body;
    const file = req.file;
    
    console.log('üß™ [TEST-AUDIO-SEND] Teste de envio de √°udio:', {
      connectionId,
      jid,
      fileName: file?.originalname,
      fileSize: file?.size,
      fileMimeType: file?.mimetype
    });
    
    if (!connectionId || !jid || !file) {
      return res.status(400).json({ 
        error: 'connectionId, jid e arquivo s√£o obrigat√≥rios' 
      });
    }
    
    const connection = activeConnections.get(connectionId);
    if (!connection || !connection.sock) {
      return res.status(404).json({ error: 'Conex√£o n√£o encontrada' });
    }
    
    const sock = connection.sock;
    const fileBuffer = fs.readFileSync(file.path);
    
    // Testar diferentes formatos de √°udio
    const audioFormats = [
      { audio: fileBuffer, ptt: true, mimetype: 'audio/ogg; codecs=opus' },
      { audio: fileBuffer, ptt: true },
      { audio: fileBuffer, mimetype: file.mimetype },
      { audio: { url: file.path }, ptt: true }
    ];
    
    const results = [];
    
    for (let i = 0; i < audioFormats.length; i++) {
      const format = audioFormats[i];
      try {
        console.log(`üß™ [TEST-AUDIO-SEND] Testando formato ${i + 1}:`, format);
        const sent = await sock.sendMessage(jid, format);
        results.push({
          format: i + 1,
          success: true,
          messageId: sent?.key?.id,
          content: format
        });
        console.log(`‚úÖ [TEST-AUDIO-SEND] Formato ${i + 1} funcionou!`);
        break; // Se funcionou, parar aqui
      } catch (error) {
        console.log(`‚ùå [TEST-AUDIO-SEND] Formato ${i + 1} falhou:`, error.message);
        results.push({
          format: i + 1,
          success: false,
          error: error.message,
          content: format
        });
      }
    }
    
    res.json({
      success: true,
      results,
      message: 'Teste de envio de √°udio conclu√≠do'
    });
    
  } catch (error) {
    console.error('‚ùå [TEST-AUDIO-SEND] Erro no teste:', error);
    res.status(500).json({ error: error.message });
  }
});

// Endpoint para testar tipos de m√≠dia aceitos
app.get('/api/baileys-simple/test-media-types', async (req, res) => {
  try {
    const { connectionId } = req.query;
    
    if (!connectionId) {
      return res.status(400).json({ error: 'connectionId √© obrigat√≥rio' });
    }
    
    const connection = activeConnections.get(connectionId);
    if (!connection || !connection.sock) {
      return res.status(404).json({ error: 'Conex√£o n√£o encontrada' });
    }
    
    const sock = connection.sock;
    
    // Testar diferentes tipos de m√≠dia
    const mediaTypes = {
      audio: {
        webm: 'audio/webm',
        ogg: 'audio/ogg',
        mp3: 'audio/mp3',
        mp4: 'audio/mp4',
        wav: 'audio/wav'
      },
      video: {
        mp4: 'video/mp4',
        webm: 'video/webm',
        avi: 'video/avi',
        mov: 'video/quicktime'
      },
      image: {
        jpeg: 'image/jpeg',
        png: 'image/png',
        gif: 'image/gif',
        webp: 'image/webp'
      }
    };
    
    res.json({
      success: true,
      supportedTypes: mediaTypes,
      message: 'Tipos de m√≠dia testados. Use estes tipos no envio de m√≠dia.'
    });
    
  } catch (error) {
    console.error('‚ùå Erro ao testar tipos de m√≠dia:', error);
    res.status(500).json({ error: error.message });
  }
});

// Endpoint para verificar status do Supabase
app.get('/api/baileys-simple/supabase-status', async (req, res) => {
  try {
    // Testar conex√£o com Supabase
    const { data, error } = await supabase
      .from('whatsapp_mensagens')
      .select('count')
      .limit(1);
    
    if (error) {
      console.error('‚ùå Erro na conex√£o com Supabase:', error);
      return res.json({
        success: false,
        error: error.message,
        isConnected: false,
        isOverLimit: error.message.includes('limit') || error.message.includes('quota')
      });
    }
    
    res.json({
      success: true,
      isConnected: true,
      isOverLimit: false,
      message: 'Supabase funcionando normalmente'
    });
  } catch (error) {
    console.error('‚ùå Erro ao verificar status do Supabase:', error);
    res.status(500).json({
      success: false,
      error: error.message,
      isConnected: false,
      isOverLimit: true
    });
  }
});

// Endpoint para testar conversas do frontend
app.get('/api/baileys-simple/test-conversations', async (req, res) => {
  try {
    const { ownerId } = req.query;
    
    if (!ownerId) {
      return res.status(400).json({ error: 'ownerId √© obrigat√≥rio' });
    }

    // Buscar mensagens do usu√°rio ordenadas por timestamp decrescente (mais recentes primeiro)
    const { data: messages, error } = await supabase
      .from('whatsapp_mensagens')
      .select('*')
      .eq('owner_id', ownerId)
      .order('timestamp', { ascending: false });

    if (error) {
      console.error('‚ùå Erro ao buscar mensagens do Supabase:', error);
      
      // Verificar se √© erro de limite/quota
      const isOverLimit = error.message.includes('limit') || error.message.includes('quota') || error.message.includes('usage');
      
      if (isOverLimit) {
        console.warn('‚ö†Ô∏è Supabase com limite de uso excedido, retornando dados em cache');
        // Retornar conversas vazias quando Supabase est√° com limite
        return res.json({
          success: true,
          conversations: [],
          total: 0,
          warning: 'Supabase com limite de uso excedido. Algumas funcionalidades podem estar limitadas.'
        });
      }
      
      return res.status(500).json({ 
        error: error.message,
        isOverLimit: isOverLimit
      });
    }

    // Agrupar por chat_id - como as mensagens j√° est√£o ordenadas por timestamp decrescente,
    // a primeira mensagem de cada chat_id ser√° a mais recente
    const conversations = new Map();
    
    for (const msg of messages || []) {
      const key = msg.chat_id;
      const existing = conversations.get(key);
      
      if (!existing) {
        // Tentar obter nome real do WhatsApp se dispon√≠vel
        let displayName = msg.wpp_name || msg.phone || 'Contato';
        let profilePicture = null;
        
        // Buscar informa√ß√µes do contato na tabela contacts
        try {
          const { data: contactInfo, error: contactError } = await supabase
            .from('contacts')
            .select('whatsapp_name, whatsapp_profile_picture, name')
            .eq('whatsapp_jid', msg.chat_id)
            .eq('owner_id', ownerId)
            .single();
          
          if (contactInfo && !contactError) {
            displayName = contactInfo.whatsapp_name || contactInfo.name || displayName;
            profilePicture = contactInfo.whatsapp_profile_picture;
          }
        } catch (error) {
          console.log('‚ö†Ô∏è Erro ao buscar informa√ß√µes do contato:', error.message);
        }
        
        // Se n√£o encontrou na tabela contacts, tentar buscar na conex√£o ativa
        if (!profilePicture && activeConnections.size > 0) {
          try {
            const connection = Array.from(activeConnections.values())[0];
            if (connection && connection.sock) {
              // Buscar informa√ß√µes do contato
              const contactInfo = connection.sock.store?.contacts?.[msg.chat_id];
              if (contactInfo && contactInfo.name && !displayName.includes('Contato')) {
                displayName = contactInfo.name;
              }
            }
          } catch (error) {
            console.log('‚ö†Ô∏è Erro ao buscar nome real do WhatsApp:', error.message);
          }
        }
        
        conversations.set(key, {
          chat_id: msg.chat_id,
          nome_cliente: displayName,
          numero_cliente: msg.phone || msg.chat_id?.split('@')[0] || '',
          last_message: msg.conteudo,
          lastMessageAt: msg.timestamp,
          last_message_remetente: msg.remetente, // Adicionar remetente da √∫ltima mensagem
          last_message_tipo: msg.tipo, // Adicionar tipo da √∫ltima mensagem
          last_message_lida: msg.lida, // Adicionar status de lida da √∫ltima mensagem
          unread_count: 0, // Inicializar como 0, ser√° calculado depois
          total_messages: 1,
          owner_id: msg.owner_id,
          connection_id: msg.connection_id,
          profile_picture: profilePicture, // Foto de perfil do WhatsApp
          whatsapp_name: displayName,
          whatsapp_jid: msg.chat_id
        });
      } else {
        existing.total_messages += 1;
        // Como as mensagens est√£o ordenadas por timestamp decrescente,
        // n√£o precisamos verificar se √© mais recente - a primeira j√° √© a mais recente
      }
    }

    // Calcular unread_count baseado apenas em mensagens n√£o lidas do CLIENTE
    // Usar uma query separada para contar mensagens n√£o lidas por chat_id
    for (const [chatId, conversation] of conversations) {
      try {
        const { count, error } = await supabase
          .from('whatsapp_mensagens')
          .select('*', { count: 'exact', head: true })
          .eq('chat_id', chatId)
          .eq('owner_id', ownerId)
          .eq('remetente', 'CLIENTE')
          .eq('lida', false);
        
        if (error) {
          console.error(`Erro ao contar mensagens n√£o lidas para ${chatId}:`, error);
          conversation.unread_count = 0;
        } else {
          conversation.unread_count = count || 0;
          console.log(`üî¥ Unread count para ${chatId}: ${conversation.unread_count}`);
        }
      } catch (error) {
        console.error(`Erro ao contar mensagens n√£o lidas para ${chatId}:`, error);
        conversation.unread_count = 0;
      }
    }

    const result = Array.from(conversations.values());
    result.sort((a, b) => new Date(b.lastMessageAt) - new Date(a.lastMessageAt));

    res.json({
      success: true,
      conversations: result,
      total: result.length
    });
  } catch (error) {
    console.error('Erro ao buscar conversas:', error);
    res.status(500).json({ error: 'Erro interno do servidor' });
  }
});

// Endpoint para sincronizar contatos do WhatsApp
app.post('/api/whatsapp-contacts/sync/:connectionId', async (req, res) => {
  try {
    const { connectionId } = req.params;
    const { ownerId } = req.body;
    
    if (!connectionId || !ownerId) {
      return res.status(400).json({ 
        success: false, 
        error: 'connectionId e ownerId s√£o obrigat√≥rios' 
      });
    }

    console.log('üîÑ [SYNC-CONTACTS] Iniciando sincroniza√ß√£o:', { connectionId, ownerId });

    const connection = activeConnections.get(connectionId);
    if (!connection || !connection.sock) {
      return res.status(404).json({ 
        success: false, 
        error: 'Conex√£o n√£o encontrada' 
      });
    }

    const sock = connection.sock;
    let syncedContacts = 0;
    let errors = 0;

    // Obter todos os contatos do WhatsApp
    const contacts = sock.store?.contacts || {};
    
    for (const [jid, contact] of Object.entries(contacts)) {
      try {
        // Pular grupos e contatos sem nome
        if (jid.includes('@g.us') || !contact.name) continue;

        const phone = jid.split('@')[0];
        
        // Verificar se contato j√° existe
        const { data: existingContact } = await supabase
          .from('contacts')
          .select('id')
          .eq('owner_id', ownerId)
          .or(`phone.eq.${phone},whatsapp_jid.eq.${jid}`)
          .single();

        const contactData = {
          owner_id: ownerId,
          name: contact.name,
          phone: phone,
          whatsapp_jid: jid,
          whatsapp_name: contact.name,
          whatsapp_connection_id: connectionId,
          whatsapp_registered_at: new Date().toISOString(),
          status: 'active',
          whatsapp_opted: true,
          ai_enabled: false,
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString(),
          last_contact_at: new Date().toISOString()
        };

        if (existingContact) {
          // Atualizar contato existente
          const { error: updateError } = await supabase
            .from('contacts')
            .update({
              whatsapp_name: contact.name,
              whatsapp_jid: jid,
              whatsapp_connection_id: connectionId,
              updated_at: new Date().toISOString()
            })
            .eq('id', existingContact.id);

          if (updateError) {
            console.error('‚ùå Erro ao atualizar contato:', updateError);
            errors++;
          } else {
            syncedContacts++;
          }
        } else {
          // Criar novo contato
          const { error: insertError } = await supabase
            .from('contacts')
            .insert(contactData);

          if (insertError) {
            console.error('‚ùå Erro ao criar contato:', insertError);
            errors++;
          } else {
            syncedContacts++;
          }
        }
      } catch (error) {
        console.error('‚ùå Erro ao processar contato:', error);
        errors++;
      }
    }

    console.log('‚úÖ [SYNC-CONTACTS] Sincroniza√ß√£o conclu√≠da:', { syncedContacts, errors });

    res.json({
      success: true,
      data: {
        syncedContacts,
        errors,
        totalContacts: Object.keys(contacts).length
      }
    });

  } catch (error) {
    console.error('‚ùå [SYNC-CONTACTS] Erro:', error);
    res.status(500).json({ 
      success: false, 
      error: error.message || 'Erro interno do servidor' 
    });
  }
});

// Endpoint para servir m√≠dias por hash
// Endpoint para testar IA diretamente (sistema antigo)
app.post('/api/test-ai-response', async (req, res) => {
  try {
    const { userId, message, messageType = 'TEXTO', mediaUrl = null } = req.body;
    
    if (!userId || !message) {
      return res.status(400).json({ error: 'userId e message s√£o obrigat√≥rios' });
    }
    
    console.log('üß™ ===== TESTE DIRETO DA IA (SISTEMA ANTIGO) =====');
    console.log('üß™ User ID:', userId);
    console.log('üß™ Message:', message);
    console.log('üß™ Message Type:', messageType);
    console.log('üß™ Media URL:', mediaUrl);
    
    const response = await generateAIResponse(message, 'test_chat_id', messageType, userId, mediaUrl);
    
    console.log('üß™ Resposta gerada:', response);
    console.log('üß™ ==============================================');
    
    res.json({ 
      success: true, 
      response: response,
      message: message,
      messageType: messageType,
      system: 'old'
    });
    
  } catch (error) {
    console.error('‚ùå Erro no teste da IA:', error);
    res.status(500).json({ error: 'Erro interno do servidor' });
  }
});

// Endpoint para testar pipeline completo
app.post('/api/test-complete-pipeline', async (req, res) => {
  try {
    const { userId, message, messageType = 'TEXTO', mediaUrl = null, connectionId = 'test_connection' } = req.body;
    
    if (!userId || !message) {
      return res.status(400).json({ error: 'userId e message s√£o obrigat√≥rios' });
    }
    
    console.log('üß™ ===== TESTE PIPELINE COMPLETO =====');
    console.log('üß™ User ID:', userId);
    console.log('üß™ Message:', message);
    console.log('üß™ Message Type:', messageType);
    console.log('üß™ Media URL:', mediaUrl);
    console.log('üß™ Connection ID:', connectionId);
    
    // Usar o sistema que funciona (n√£o o pipeline complexo)
    const aiResponse = await generateAIResponse(message, 'test_chat_id', messageType, userId, mediaUrl);
    console.log('üß™ Resposta gerada pela IA:', aiResponse);
    
    if (aiResponse) {
      console.log('üß™ ‚úÖ Pipeline completo executado com sucesso!');
      
      res.json({ 
        success: true, 
        message: 'Pipeline completo executado com sucesso',
        aiResponse: aiResponse,
        messageType: messageType,
        system: 'simple'
      });
    } else {
      res.json({ 
        success: false, 
        message: 'Nenhuma resposta IA gerada',
        system: 'simple'
      });
    }
    
    console.log('üß™ ======================================');
    
  } catch (error) {
    console.error('‚ùå Erro no teste do pipeline completo:', error);
    res.status(500).json({ error: 'Erro interno do servidor', details: error.message });
  }
});

// Endpoint para testar novo pipeline de IA
app.post('/api/test-new-ai-pipeline', async (req, res) => {
  try {
    const { userId, message, messageType = 'TEXTO', mediaUrl = null, connectionId = 'test_connection' } = req.body;
    
    if (!userId || !message) {
      return res.status(400).json({ error: 'userId e message s√£o obrigat√≥rios' });
    }
    
    console.log('üß™ ===== TESTE NOVO PIPELINE DE IA =====');
    console.log('üß™ User ID:', userId);
    console.log('üß™ Message:', message);
    console.log('üß™ Message Type:', messageType);
    console.log('üß™ Media URL:', mediaUrl);
    console.log('üß™ Connection ID:', connectionId);
    
    const { onIncomingMessage, shouldProcessMessage } = require('./src/wa/onIncomingMessage.ts');
    
    const testMessage = {
      ownerId: userId,
      connectionId: connectionId,
      chatId: 'test_chat_id',
      messageId: `test_${Date.now()}`,
      fromPhone: 'test_phone',
      type: messageType,
      text: message,
      media_url: mediaUrl,
      media_mime: null
    };
    
    if (shouldProcessMessage(testMessage)) {
      await onIncomingMessage(testMessage);
      console.log('üß™ ‚úÖ Novo pipeline executado com sucesso!');
      
      res.json({ 
        success: true, 
        message: 'Novo pipeline executado com sucesso',
        messageType: messageType,
        system: 'new'
      });
    } else {
      res.json({ 
        success: false, 
        message: 'Mensagem n√£o processada (n√£o atendeu aos crit√©rios)',
        system: 'new'
      });
    }
    
    console.log('üß™ ======================================');
    
  } catch (error) {
    console.error('‚ùå Erro no teste do novo pipeline:', error);
    res.status(500).json({ error: 'Erro interno do servidor', details: error.message });
  }
});

// Endpoint para testar m√≠dia espec√≠fica
app.post('/api/test-media-support', async (req, res) => {
  try {
    const { userId, messageType, mediaUrl } = req.body;
    
    if (!userId || !messageType || !mediaUrl) {
      return res.status(400).json({ error: 'userId, messageType e mediaUrl s√£o obrigat√≥rios' });
    }
    
    console.log('üß™ ===== TESTE DE SUPORTE A M√çDIA =====');
    console.log('üß™ User ID:', userId);
    console.log('üß™ Message Type:', messageType);
    console.log('üß™ Media URL:', mediaUrl);
    
    // Testar an√°lise de m√≠dia
    const { analyzeMediaContent } = require('./src/ai/infer.ts');
    
    try {
      const mediaContent = await analyzeMediaContent(messageType, mediaUrl, { api_key: process.env.OPENAI_API_KEY });
      console.log('üß™ Conte√∫do analisado:', mediaContent);
      
      res.json({ 
        success: true, 
        mediaContent,
        messageType,
        mediaUrl,
        message: 'M√≠dia analisada com sucesso'
      });
    } catch (error) {
      console.error('‚ùå Erro na an√°lise de m√≠dia:', error);
      res.status(500).json({ 
        error: 'Erro na an√°lise de m√≠dia', 
        details: error.message 
      });
    }
    
    console.log('üß™ ====================================');
    
  } catch (error) {
    console.error('‚ùå Erro no teste de m√≠dia:', error);
    res.status(500).json({ error: 'Erro interno do servidor', details: error.message });
  }
});

// Endpoint para inicializar bucket de m√≠dia
app.post('/api/init-media-bucket', async (req, res) => {
  try {
    console.log('üìé Inicializando bucket de m√≠dia...');
    
    const { ensureMediaBucket } = require('./src/media/ingest.ts');
    await ensureMediaBucket();
    
    res.json({ 
      success: true, 
      message: 'Bucket de m√≠dia inicializado com sucesso' 
    });
  } catch (error) {
    console.error('‚ùå Erro ao inicializar bucket de m√≠dia:', error);
    res.status(500).json({ error: 'Erro ao inicializar bucket de m√≠dia' });
  }
});

// Endpoint para ativar IA para todos os contatos
app.post('/api/activate-ai-for-all-contacts', async (req, res) => {
  try {
    const { userId } = req.body;
    
    if (!userId) {
      return res.status(400).json({ error: 'userId √© obrigat√≥rio' });
    }
    
    console.log('ü§ñ Ativando IA para todos os contatos do usu√°rio:', userId);
    
    // Primeiro, verificar quantos contatos existem
    const { data: existingContacts, error: countError } = await supabase
      .from('contacts')
      .select('id, phone, name')
      .eq('owner_id', userId);
    
    if (countError) {
      console.error('‚ùå Erro ao buscar contatos:', countError);
      return res.status(500).json({ error: 'Erro ao buscar contatos' });
    }
    
    console.log('ü§ñ Contatos encontrados:', existingContacts?.length || 0);
    
    // Ativar IA para todos os contatos
    const { data, error } = await supabase
      .from('contacts')
      .update({ ai_enabled: true })
      .eq('owner_id', userId);
    
    if (error) {
      console.error('‚ùå Erro ao ativar IA para contatos:', error);
      return res.status(500).json({ error: 'Erro ao ativar IA para contatos' });
    }
    
    console.log('‚úÖ IA ativada para todos os contatos');
    res.json({ 
      success: true, 
      message: 'IA ativada para todos os contatos',
      contactsUpdated: existingContacts?.length || 0
    });
    
  } catch (error) {
    console.error('‚ùå Erro no endpoint activate-ai-for-all-contacts:', error);
    res.status(500).json({ error: 'Erro interno do servidor' });
  }
});

app.get('/api/media/:hash', async (req, res) => {
  try {
    const { hash } = req.params;
    console.log('üìé Buscando m√≠dia por hash:', hash);
    
    // Buscar m√≠dia no banco de dados
    const { data: mediaData, error } = await supabase
      .from('whatsapp_mensagens')
      .select('midia_url, midia_tipo, raw_data, midia_mime_text')
      .ilike('midia_url', `media:${hash}`)
      .limit(1)
      .single();
    
    if (error || !mediaData) {
      console.log('‚ùå M√≠dia n√£o encontrada para hash:', hash);
      return res.status(404).json({ error: 'M√≠dia n√£o encontrada' });
    }
    
    console.log('üìé M√≠dia encontrada:', { url: mediaData.midia_url, tipo: mediaData.midia_tipo });
    
    // Verificar se temos dados de m√≠dia no raw_data
    if (mediaData.raw_data && mediaData.raw_data.mediaData) {
      console.log('üìé Servindo dados bin√°rios armazenados');
      const mediaDataBuffer = mediaData.raw_data.mediaData;
      
      let buffer;
      if (Buffer.isBuffer(mediaDataBuffer)) {
        buffer = mediaDataBuffer;
      } else if (typeof mediaDataBuffer === 'string') {
        // Se √© string base64
        buffer = Buffer.from(mediaDataBuffer, 'base64');
      } else {
        console.log('‚ùå Formato de dados n√£o suportado:', typeof mediaDataBuffer);
        return res.status(500).json({ error: 'Formato de dados n√£o suportado' });
      }
      
      // Usar MIME type do banco se dispon√≠vel
      const contentType = mediaData.midia_mime_text || 
        (mediaData.midia_tipo === 'IMAGEM' ? 'image/jpeg' : 
         mediaData.midia_tipo === 'AUDIO' ? 'audio/ogg' : 
         mediaData.midia_tipo === 'VIDEO' ? 'video/mp4' : 'application/octet-stream');
      
      res.setHeader('Content-Type', contentType);
      res.setHeader('Content-Length', buffer.length);
      res.setHeader('Cache-Control', 'public, max-age=31536000');
      res.setHeader('Access-Control-Allow-Origin', '*');
      res.send(buffer);
      return;
    }
    
    // Se a m√≠dia est√° armazenada como base64
    if (mediaData.midia_url && mediaData.midia_url.startsWith('data:')) {
      const base64Data = mediaData.midia_url.split(',')[1];
      const buffer = Buffer.from(base64Data, 'base64');
      
      res.setHeader('Content-Type', mediaData.midia_tipo || 'application/octet-stream');
      res.setHeader('Content-Length', buffer.length);
      res.send(buffer);
    } else if (mediaData.midia_url && mediaData.midia_url.startsWith('http')) {
      // Se √© uma URL externa, fazer proxy
      const response = await fetch(mediaData.midia_url);
      if (!response.ok) {
        return res.status(404).json({ error: 'M√≠dia n√£o encontrada' });
      }
      
      const buffer = await response.buffer();
      res.setHeader('Content-Type', mediaData.midia_tipo || 'application/octet-stream');
      res.setHeader('Content-Length', buffer.length);
      res.send(buffer);
    } else {
      // Para m√≠dias com hash, retornar uma mensagem informativa
      console.log('‚ö†Ô∏è M√≠dia com hash encontrada, mas dados n√£o dispon√≠veis');
      return res.status(404).json({ 
        error: 'Dados da m√≠dia n√£o dispon√≠veis',
        message: 'Esta m√≠dia foi processada antes da implementa√ß√£o completa do sistema de armazenamento. As novas m√≠dias ser√£o suportadas corretamente.',
        hash: hash,
        type: mediaData.midia_tipo
      });
    }
    
  } catch (error) {
    console.error('‚ùå Erro ao servir m√≠dia:', error);
    res.status(500).json({ error: 'Erro interno do servidor' });
  }
});

// Enviar m√≠dia com convers√£o FFmpeg (novo endpoint otimizado)
app.post('/api/baileys-simple/send-media-optimized', upload.single('file'), async (req, res) => {
  try {
    const { connectionId, jid, type, caption } = req.body;
    const file = req.file;

    console.log('üì§ [SEND-MEDIA-OPTIMIZED] Recebida requisi√ß√£o:', { 
      connectionId, 
      jid, 
      type, 
      fileName: file?.originalname,
      caption: caption || 'Sem legenda',
      fileSize: file?.size,
      fileMimeType: file?.mimetype
    });

    if (!connectionId || !jid || !type || !file) {
      console.error('‚ùå [SEND-MEDIA-OPTIMIZED] Par√¢metros obrigat√≥rios ausentes:', {
        hasConnectionId: !!connectionId,
        hasJid: !!jid,
        hasType: !!type,
        hasFile: !!file
      });
      return res.status(400).json({ 
        success: false, 
        error: 'connectionId, jid, type e file s√£o obrigat√≥rios' 
      });
    }

    const connection = activeConnections.get(connectionId);
    if (!connection || !connection.sock) {
      console.error(`‚ùå [SEND-MEDIA-OPTIMIZED] Conex√£o n√£o encontrada: ${connectionId}`);
      return res.status(404).json({ 
        success: false, 
        error: 'Connection not found' 
      });
    }
    
    const sock = connection.sock;
    
    console.log('üîç [SEND-MEDIA-OPTIMIZED] Antes da normaliza√ß√£o JID:', jid);
    
    // Normaliza√ß√£o e valida√ß√£o robusta do JID
    let chatJid;
    
    // Limpar JID de caracteres especiais, mas preservar o formato completo
    // N√£o remover caracteres se o JID j√° tem formato v√°lido
    let cleanJid;
    if (jid.includes('@s.whatsapp.net') || jid.includes('@c.us') || jid.includes('@g.us')) {
      cleanJid = jid; // Usar JID original se j√° tem formato v√°lido
    } else {
      cleanJid = jid.replace(/[^\d@.]/g, ''); // Limpar apenas se necess√°rio
    }
    console.log('üßπ [SEND-MEDIA-OPTIMIZED] JID limpo:', cleanJid);
    console.log('üîç [SEND-MEDIA-OPTIMIZED] JID completo para debug:', cleanJid);
    
    if (/^\d+$/.test(cleanJid)) {
      chatJid = `${cleanJid}@s.whatsapp.net`;
    } else if (cleanJid.includes('@c.us')) {
      chatJid = cleanJid.replace('@c.us', '@s.whatsapp.net');
    } else if (cleanJid.includes('@g.us')) {
      chatJid = cleanJid; // Preservar grupos
    } else if (cleanJid.includes('@s.whatsapp.net')) {
      chatJid = cleanJid;
    } else if (cleanJid.includes('@')) {
      // Se tem @ mas n√£o √© um formato conhecido, tentar usar como est√°
      chatJid = cleanJid;
    } else {
      chatJid = `${cleanJid}@s.whatsapp.net`;
    }
    
    // Valida√ß√£o mais flex√≠vel do JID - permitir diferentes formatos
    const jidPatterns = [
      /^(\d+)@s\.whatsapp\.net$/,  // Formato padr√£o
      /^(\d+)@c\.us$/,             // Formato alternativo
      /^(\d+)@g\.us$/,             // Grupos do WhatsApp
      /^(\d+)$/                    // Apenas n√∫mero
    ];
    
    let jidMatch = null;
    let finalJid = chatJid;
    
    console.log('üîç [SEND-MEDIA-OPTIMIZED] Validando JID:', chatJid);
    
    for (const pattern of jidPatterns) {
      const match = chatJid.match(pattern);
      if (match) {
        jidMatch = match;
        console.log('‚úÖ [SEND-MEDIA-OPTIMIZED] JID corresponde ao padr√£o:', pattern.source);
        // Normalizar para formato padr√£o
        if (pattern.source === '^(\\d+)$') {
          finalJid = `${match[1]}@s.whatsapp.net`;
        } else if (pattern.source === '^(\\d+)@c\\.us$') {
          finalJid = `${match[1]}@s.whatsapp.net`;
        }
        break;
      }
    }
    
    if (!jidMatch) {
      console.error('‚ùå [SEND-MEDIA-OPTIMIZED] JID inv√°lido ap√≥s normaliza√ß√£o:', chatJid);
      console.error('‚ùå [SEND-MEDIA-OPTIMIZED] JID original:', jid);
      console.error('‚ùå [SEND-MEDIA-OPTIMIZED] JID limpo:', cleanJid);
      console.error('‚ùå [SEND-MEDIA-OPTIMIZED] Padr√µes testados:', jidPatterns.map(p => p.source));
      
      // Tentar usar o JID original se a valida√ß√£o falhar
      if (jid && jid.includes('@')) {
        console.log('üîÑ [SEND-MEDIA-OPTIMIZED] Tentando usar JID original:', jid);
        finalJid = jid;
        jidMatch = { 1: jid.split('@')[0] };
      } else {
        return res.status(400).json({
          success: false,
          error: `JID inv√°lido: ${chatJid}. Deve ser um n√∫mero de telefone v√°lido`
        });
      }
    }
    
    chatJid = finalJid;
    
    const phoneNumber = jidMatch[1];
    console.log('‚úÖ [SEND-MEDIA-OPTIMIZED] JID normalizado e validado:', chatJid);
    console.log('üì± [SEND-MEDIA-OPTIMIZED] N√∫mero de telefone extra√≠do:', phoneNumber);

    // Preparar conte√∫do baseado no tipo
    let content;
    let finalFilePath = file.path;
    let tempFiles = [file.path]; // Lista de arquivos tempor√°rios para limpeza

    // Para √°udio, tentar convers√£o FFmpeg se dispon√≠vel (opcional)
    if (type === 'audio') {
      try {
        // Verificar se FFmpeg est√° dispon√≠vel
        const { exec } = require('child_process');
        const { promisify } = require('util');
        const execAsync = promisify(exec);
          
          await execAsync('ffmpeg -version');
          console.log('‚úÖ FFmpeg dispon√≠vel, convertendo √°udio...');
          
          // Criar arquivo tempor√°rio convertido
          const convertedPath = file.path.replace(/\.[^/.]+$/, '_converted.ogg');
          tempFiles.push(convertedPath);
          
          // Comando FFmpeg para convers√£o otimizada para WhatsApp
          const ffmpegCommand = `ffmpeg -i "${file.path}" -c:a libopus -ac 1 -ar 48000 -b:a 64k -avoid_negative_ts make_zero -y "${convertedPath}"`;
          
          console.log('üîÑ Executando convers√£o FFmpeg:', ffmpegCommand);
          const { stdout, stderr } = await execAsync(ffmpegCommand);
          
          if (stderr && stderr.includes('error')) {
            console.warn('‚ö†Ô∏è Aviso no FFmpeg (continuando):', stderr);
          }
          
          if (fs.existsSync(convertedPath)) {
            finalFilePath = convertedPath;
            console.log('‚úÖ √Åudio convertido com sucesso');
          } else {
            console.warn('‚ö†Ô∏è Convers√£o falhou, usando arquivo original');
          }
          
        } catch (ffmpegError) {
          console.log('‚ÑπÔ∏è FFmpeg n√£o dispon√≠vel, enviando arquivo original (isso √© normal):', ffmpegError.message);
          // Continuar com o arquivo original - n√£o √© um erro cr√≠tico
        }
      }

      // Para v√≠deo, tentar convers√£o FFmpeg se dispon√≠vel (opcional)
      if (type === 'video') {
        try {
          const { exec } = require('child_process');
          const { promisify } = require('util');
          const execAsync = promisify(exec);
          
          await execAsync('ffmpeg -version');
          console.log('‚úÖ FFmpeg dispon√≠vel, convertendo v√≠deo...');
          
          // Criar arquivo tempor√°rio convertido
          const convertedPath = file.path.replace(/\.[^/.]+$/, '_converted.mp4');
          tempFiles.push(convertedPath);
          
          // Comando FFmpeg para v√≠deo otimizado para WhatsApp
          const ffmpegCommand = `ffmpeg -i "${file.path}" -c:v libx264 -crf 23 -vf "scale='min(720,iw)':'min(1280,ih)':force_original_aspect_ratio=decrease" -c:a aac -b:a 128k -movflags +faststart -y "${convertedPath}"`;
          
          console.log('üîÑ Executando convers√£o FFmpeg:', ffmpegCommand);
          const { stdout, stderr } = await execAsync(ffmpegCommand);
          
          if (stderr && stderr.includes('error')) {
            console.warn('‚ö†Ô∏è Aviso no FFmpeg (continuando):', stderr);
          }
          
          if (fs.existsSync(convertedPath)) {
            finalFilePath = convertedPath;
            console.log('‚úÖ V√≠deo convertido com sucesso');
          } else {
            console.warn('‚ö†Ô∏è Convers√£o falhou, usando arquivo original');
          }
          
        } catch (ffmpegError) {
          console.log('‚ÑπÔ∏è FFmpeg n√£o dispon√≠vel, enviando arquivo original (isso √© normal):', ffmpegError.message);
          // Continuar com o arquivo original - n√£o √© um erro cr√≠tico
        }
      }

      // Ler arquivo final (convertido ou original)
      const fileBuffer = fs.readFileSync(finalFilePath);
      
      // Determinar MIME type baseado no arquivo final
      let finalMimeType = file.mimetype;
      if (finalFilePath.endsWith('.ogg')) {
        finalMimeType = 'audio/ogg; codecs=opus';
      } else if (finalFilePath.endsWith('.mp4')) {
        finalMimeType = 'video/mp4';
      }

      // Preparar conte√∫do baseado no tipo
      switch (type) {
        case 'image':
          content = { 
            image: fileBuffer, 
            caption: caption || '',
            mimetype: finalMimeType
          };
          break;
        case 'video':
          content = { 
            video: fileBuffer, 
            caption: caption || '',
            mimetype: finalMimeType
          };
          break;
        case 'audio':
          // Valida√ß√£o espec√≠fica para √°udio
          if (fileBuffer.length === 0) {
            console.error('‚ùå [SEND-MEDIA-OPTIMIZED] Arquivo de √°udio vazio');
            return res.status(400).json({
              success: false,
              error: 'Arquivo de √°udio vazio'
            });
          }
          
          // Formato simplificado para √°udio conforme recomendado
          content = { 
            audio: fileBuffer, 
            ptt: true,
            mimetype: 'audio/ogg; codecs=opus'
          };
          console.log('üé§ [SEND-MEDIA-OPTIMIZED] Conte√∫do de √°udio preparado (formato simplificado):', {
            size: fileBuffer.length,
            ptt: true,
            mimetype: 'audio/ogg; codecs=opus'
          });
          break;
        case 'document':
          content = { 
            document: fileBuffer, 
            fileName: file.originalname,
            mimetype: finalMimeType
          };
          break;
        default:
          return res.status(400).json({ 
            success: false, 
            error: 'Tipo de m√≠dia n√£o suportado' 
          });
      }

      // Enviar via Baileys
      console.log('üì§ [SEND-MEDIA-OPTIMIZED] Enviando via Baileys:', { 
        chatJid, 
        type, 
        mimeType: finalMimeType,
        contentKeys: Object.keys(content),
        contentSize: fileBuffer.length
      });
      
      try {
        // Verificar se o JID est√° no formato correto antes de enviar
        console.log('üîç [SEND-MEDIA-OPTIMIZED] Verificando JID antes do envio:', chatJid);
        
        // Validar JID uma vez mais - aceitar grupos tamb√©m
        if (!chatJid.match(/^\d+@(s\.whatsapp\.net|g\.us)$/)) {
          throw new Error(`JID inv√°lido: ${chatJid}. Deve estar no formato: n√∫mero@s.whatsapp.net ou n√∫mero@g.us`);
        }
        
        // Verificar se o conte√∫do tem dados v√°lidos
        if (type === 'audio') {
          if (!content.audio || content.audio.length === 0) {
            throw new Error('Conte√∫do de √°udio vazio ou inv√°lido');
          }
          
          // Validar se o buffer de √°udio √© v√°lido
          if (!Buffer.isBuffer(content.audio)) {
            console.log('üîÑ [SEND-MEDIA-OPTIMIZED] Convertendo conte√∫do para Buffer...');
            content.audio = Buffer.from(content.audio);
          }
          
          // Verificar se o buffer n√£o est√° vazio
          if (content.audio.length === 0) {
            throw new Error('Buffer de √°udio vazio');
          }
          
          console.log('‚úÖ [SEND-MEDIA-OPTIMIZED] Conte√∫do de √°udio validado:', {
            bufferLength: content.audio.length,
            bufferType: typeof content.audio,
            isBuffer: Buffer.isBuffer(content.audio)
          });
        }
        
        console.log('üì§ [SEND-MEDIA-OPTIMIZED] Enviando via Baileys...', {
          jid: chatJid,
          type: type,
          contentSize: fileBuffer.length,
          hasAudio: !!content.audio,
          ptt: content.ptt
        });
        
        // Tentar envio com valida√ß√£o adicional
        let sent;
        try {
          sent = await sock.sendMessage(chatJid, content, {
            linkPreview: false
          });
        } catch (sendError) {
          console.error('‚ùå [SEND-MEDIA-OPTIMIZED] Erro ao enviar via Baileys:', sendError.message);
          throw sendError;
        }
        
        console.log('‚úÖ [SEND-MEDIA-OPTIMIZED] M√≠dia enviada via Baileys:', { 
          messageId: sent?.key?.id,
          status: sent?.status
        });
        
        // M√≠dia enviada com sucesso, continuar com o processamento

        // Salvar m√≠dia no Supabase Storage e obter URL
        let mediaUrl = null;
        // Limpar MIME type para nome do arquivo (remover codecs e caracteres especiais)
        const cleanMimeType = finalMimeType.split(';')[0].split('/')[1] || 'bin';
        const fileName = `media_${Date.now()}_${Math.random().toString(36).substr(2, 9)}.${cleanMimeType}`;
        
        // Upload para Supabase Storage
        const { error: uploadError } = await supabaseAdmin.storage
          .from('whatsapp')
          .upload(fileName, fileBuffer, {
            contentType: finalMimeType,
            upsert: false
          });
        
        if (uploadError) {
          console.error('‚ùå [SEND-MEDIA-OPTIMIZED] Erro ao fazer upload da m√≠dia:', uploadError);
        } else {
          console.log('‚úÖ [SEND-MEDIA-OPTIMIZED] M√≠dia salva no Supabase:', fileName);
          
          // Criar URL p√∫blica
          const { data: signedUrl } = await supabaseAdmin.storage
            .from('whatsapp')
            .createSignedUrl(fileName, 60 * 60 * 24 * 30); // 30 dias
          
          if (signedUrl) {
            mediaUrl = signedUrl.signedUrl;
            console.log('‚úÖ [SEND-MEDIA-OPTIMIZED] URL p√∫blica criada:', mediaUrl);
          }
        }

        // Salvar no banco
        const { ownerId, connectionPhone } = await getSessionInfo(connectionId, supabase);
        const nowIso = new Date().toISOString();

        const messageData = {
          id: crypto.randomUUID(),
          owner_id: ownerId,
          atendimento_id: null,
          connection_id: connectionId,
          connection_phone: connectionPhone,
          chat_id: chatJid,
          phone: chatJid.split('@')[0],
          conteudo: caption || `[${type === 'audio' ? '√Åudio' : type === 'video' ? 'V√≠deo' : type === 'image' ? 'Imagem' : 'Arquivo'}]`,
          message_id: sent?.key?.id ?? null,
          message_type: type === 'image' ? 'IMAGEM'
                       : type === 'video' ? 'VIDEO'
                       : type === 'audio' ? 'AUDIO'
                       : 'ARQUIVO',
          media_type: finalMimeType,
          remetente: 'ATENDENTE',
          status: 'ATENDIDO',
          timestamp: nowIso,
          lida: true,
          media_url: mediaUrl, // URL da m√≠dia no Supabase Storage
          media_mime: finalMimeType,
          duration_ms: null,
          wpp_name: 'Atendente',
          group_contact_name: null
        };

        console.log('üíæ [SEND-MEDIA-OPTIMIZED] Salvando no Supabase:', messageData);
        const { error: dbErr } = await supabase.from('whatsapp_mensagens').insert(messageData);
        if (dbErr) {
          console.error('‚ùå [SEND-MEDIA-OPTIMIZED] Erro ao salvar no Supabase:', dbErr);
          // N√£o falhar a requisi√ß√£o por erro de banco
        }

        // Limpar arquivos tempor√°rios
        tempFiles.forEach(tempFile => {
          try {
            if (fs.existsSync(tempFile) && tempFile !== file.path) {
              fs.unlinkSync(tempFile);
              console.log('üóëÔ∏è Arquivo tempor√°rio removido:', tempFile);
            }
          } catch (cleanupError) {
            console.warn('‚ö†Ô∏è Erro ao limpar arquivo tempor√°rio:', tempFile, cleanupError.message);
          }
        });

        res.json({
          success: true,
          data: {
            messageId: sent?.key?.id,
            type: type,
            mimeType: finalMimeType,
            caption: caption || null,
            timestamp: nowIso
          }
        });

    } catch (error) {
      console.error('‚ùå [SEND-MEDIA-OPTIMIZED] Erro:', error);
      
      // Limpar arquivos tempor√°rios em caso de erro
      tempFiles.forEach(tempFile => {
        try {
          if (fs.existsSync(tempFile) && tempFile !== file.path) {
            fs.unlinkSync(tempFile);
          }
        } catch (cleanupError) {
          console.warn('‚ö†Ô∏è Erro ao limpar arquivo tempor√°rio:', tempFile, cleanupError.message);
        }
      });
      
      res.status(500).json({ 
        success: false, 
        error: error.message || 'Erro interno do servidor' 
      });
    }
  } catch (error) {
    console.error('‚ùå [SEND-MEDIA-OPTIMIZED] Erro geral:', error);
    res.status(500).json({ 
      success: false, 
      error: error.message || 'Erro interno do servidor' 
    });
  }
});

// Endpoint de teste para debug de JID
app.post('/api/baileys-simple/test-jid', async (req, res) => {
  try {
    const { jid } = req.body;
    
    console.log('üß™ [TEST-JID] Testando JID:', jid);
    
    // Normaliza√ß√£o simples
    let chatJid;
    if (/^\d+$/.test(jid)) {
      chatJid = `${jid}@s.whatsapp.net`;
    } else if (jid.includes('@c.us')) {
      chatJid = jid.replace('@c.us', '@s.whatsapp.net');
    } else if (jid.includes('@s.whatsapp.net')) {
      chatJid = jid;
    } else {
      chatJid = `${jid}@s.whatsapp.net`;
    }
    
    // Validar formato
    const isValid = chatJid.match(/^\d+@s\.whatsapp\.net$/);
    
    res.json({
      success: true,
      data: {
        originalJid: jid,
        normalizedJid: chatJid,
        isValid: !!isValid,
        pattern: /^\d+@s\.whatsapp\.net$/.toString()
      }
    });
    
  } catch (error) {
    console.error('‚ùå [TEST-JID] Erro:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Endpoint de teste espec√≠fico para √°udio
app.post('/api/baileys-simple/test-audio', upload.single('file'), async (req, res) => {
  try {
    const { connectionId, jid } = req.body;
    const file = req.file;

    console.log('üß™ [TEST-AUDIO] Testando envio de √°udio:', { 
      connectionId, 
      jid, 
      fileName: file?.originalname,
      fileSize: file?.size
    });

    if (!connectionId || !jid || !file) {
      return res.status(400).json({ 
        success: false, 
        error: 'connectionId, jid e file s√£o obrigat√≥rios' 
      });
    }

    const connection = activeConnections.get(connectionId);
    if (!connection || !connection.sock) {
      return res.status(404).json({ 
        success: false, 
        error: 'Connection not found' 
      });
    }

    const sock = connection.sock;
    
    // Normaliza√ß√£o simples do JID
    let chatJid;
    if (/^\d+$/.test(jid)) {
      chatJid = `${jid}@s.whatsapp.net`;
    } else if (jid.includes('@c.us')) {
      chatJid = jid.replace('@c.us', '@s.whatsapp.net');
    } else if (jid.includes('@s.whatsapp.net')) {
      chatJid = jid;
    } else {
      chatJid = `${jid}@s.whatsapp.net`;
    }

    console.log('üß™ [TEST-AUDIO] JID normalizado:', chatJid);

    // Ler arquivo
    const fileBuffer = fs.readFileSync(file.path);
    console.log('üß™ [TEST-AUDIO] Arquivo lido:', { size: fileBuffer.length });

    // Conte√∫do mais simples poss√≠vel
    const content = { 
      audio: fileBuffer, 
      ptt: true
    };

    console.log('üß™ [TEST-AUDIO] Conte√∫do preparado:', {
      hasAudio: !!content.audio,
      audioSize: content.audio?.length,
      ptt: content.ptt
    });

    // Tentar envio
    try {
      const sent = await sock.sendMessage(chatJid, content);
      console.log('‚úÖ [TEST-AUDIO] √Åudio enviado com sucesso:', { messageId: sent?.key?.id });
      
      res.json({
        success: true,
        data: {
          messageId: sent?.key?.id,
          jid: chatJid,
          fileSize: fileBuffer.length
        }
      });
    } catch (sendError) {
      console.error('‚ùå [TEST-AUDIO] Erro ao enviar:', sendError);
      res.status(500).json({
        success: false,
        error: sendError.message,
        details: {
          jid: chatJid,
          fileSize: fileBuffer.length,
          errorType: sendError.constructor.name
        }
      });
    }

  } catch (error) {
    console.error('‚ùå [TEST-AUDIO] Erro geral:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Endpoint de debug espec√≠fico para erro de padr√£o
app.post('/api/baileys-simple/debug-pattern-error', upload.single('file'), async (req, res) => {
  try {
    const { connectionId, jid } = req.body;
    const file = req.file;

    console.log('üîç [DEBUG-PATTERN] Debugando erro de padr√£o:', { 
      connectionId, 
      jid, 
      fileName: file?.originalname,
      fileSize: file?.size
    });

    if (!connectionId || !jid || !file) {
      return res.status(400).json({ 
        success: false, 
        error: 'connectionId, jid e file s√£o obrigat√≥rios' 
      });
    }

    const connection = activeConnections.get(connectionId);
    if (!connection || !connection.sock) {
      return res.status(404).json({ 
        success: false, 
        error: 'Connection not found' 
      });
    }

    const sock = connection.sock;
    
    // Testar diferentes formatos de JID
    const jidFormats = [
      jid, // Original
      jid.includes('@') ? jid : `${jid}@s.whatsapp.net`, // Com @s.whatsapp.net
      jid.includes('@') ? jid.replace('@s.whatsapp.net', '@c.us') : `${jid}@c.us`, // Com @c.us
      jid.replace(/[^\d]/g, '') + '@s.whatsapp.net', // Apenas n√∫meros + @s.whatsapp.net
    ];

    console.log('üîç [DEBUG-PATTERN] Formatos de JID para testar:', jidFormats);

    // Ler arquivo
    const fileBuffer = fs.readFileSync(file.path);
    console.log('üîç [DEBUG-PATTERN] Arquivo lido:', { size: fileBuffer.length });

    // Testar diferentes formatos de conte√∫do
    const contentFormats = [
      { audio: fileBuffer, ptt: true },
      { audio: fileBuffer },
      { audio: fileBuffer, ptt: true, mimetype: 'audio/webm' },
      { audio: fileBuffer, ptt: true, mimetype: 'audio/ogg' },
    ];

    console.log('üîç [DEBUG-PATTERN] Formatos de conte√∫do para testar:', contentFormats.length);

    const results = [];

    for (let i = 0; i < jidFormats.length; i++) {
      const testJid = jidFormats[i];
      console.log(`üîç [DEBUG-PATTERN] Testando JID ${i + 1}/${jidFormats.length}: ${testJid}`);
      
      for (let j = 0; j < contentFormats.length; j++) {
        const testContent = contentFormats[j];
        console.log(`üîç [DEBUG-PATTERN] Testando conte√∫do ${j + 1}/${contentFormats.length}:`, Object.keys(testContent));
        
        try {
          const sent = await sock.sendMessage(testJid, testContent);
          console.log(`‚úÖ [DEBUG-PATTERN] Sucesso com JID ${i + 1}, conte√∫do ${j + 1}:`, { messageId: sent?.key?.id });
          
          results.push({
            success: true,
            jid: testJid,
            content: Object.keys(testContent),
            messageId: sent?.key?.id
          });
          
          // Se funcionou, retornar sucesso
          return res.json({
            success: true,
            data: {
              workingJid: testJid,
              workingContent: Object.keys(testContent),
              messageId: sent?.key?.id,
              allResults: results
            }
          });
          
        } catch (error) {
          console.log(`‚ùå [DEBUG-PATTERN] Falha com JID ${i + 1}, conte√∫do ${j + 1}:`, error.message);
          
          results.push({
            success: false,
            jid: testJid,
            content: Object.keys(testContent),
            error: error.message
          });
        }
      }
    }

    // Se chegou aqui, nenhum formato funcionou
    res.status(500).json({
      success: false,
      error: 'Nenhum formato de JID ou conte√∫do funcionou',
      results: results
    });

  } catch (error) {
    console.error('‚ùå [DEBUG-PATTERN] Erro geral:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Endpoint para limpar media:hash existentes
app.post('/api/cleanup-media-hashes', async (req, res) => {
  try {
    const { userId } = req.body;
    
    if (!userId) {
      return res.status(400).json({
        success: false,
        error: 'userId √© obrigat√≥rio'
      });
    }
    
    console.log('üßπ [CLEANUP-MEDIA] Iniciando limpeza de media:hash para usu√°rio:', userId);
    
    // Buscar mensagens com media:hash
    const { data: messagesWithHashes } = await supabaseAdmin
      .from('whatsapp_mensagens')
      .select('*')
      .eq('owner_id', userId)
      .like('media_url', 'media:%');
    
    console.log(`üìä [CLEANUP-MEDIA] Encontradas ${messagesWithHashes?.length || 0} mensagens com media:hash`);
    
    if (!messagesWithHashes || messagesWithHashes.length === 0) {
      return res.json({ 
        success: true, 
        cleaned: 0,
        message: 'Nenhuma mensagem com media:hash encontrada'
      });
    }
    
    // Atualizar essas mensagens para mostrar "M√≠dia n√£o dispon√≠vel"
    const { error } = await supabaseAdmin
      .from('whatsapp_mensagens')
      .update({ 
        media_url: null,
        media_mime: null,
        media_type: null,
        conteudo: '[M√≠dia n√£o dispon√≠vel - atualizado pelo sistema]'
      })
      .eq('owner_id', userId)
      .like('media_url', 'media:%');
    
    if (error) {
      console.error('‚ùå [CLEANUP-MEDIA] Erro ao limpar media:hash:', error);
      return res.status(500).json({
        success: false,
        error: 'Erro ao limpar media:hash',
        details: error.message
      });
    }
    
    console.log(`‚úÖ [CLEANUP-MEDIA] Limpeza conclu√≠da: ${messagesWithHashes.length} mensagens atualizadas`);
    
    res.json({ 
      success: true, 
      cleaned: messagesWithHashes.length,
      message: `${messagesWithHashes.length} mensagens com media:hash foram limpas`
    });
    
  } catch (error) {
    console.error('‚ùå [CLEANUP-MEDIA] Erro geral:', error);
    res.status(500).json({
      success: false,
      error: 'Erro interno do servidor',
      details: error.message
    });
  }
});

// Endpoint para verificar e criar bucket do Supabase
app.post('/api/check-supabase-bucket', async (req, res) => {
  try {
    console.log('üîç Verificando bucket do Supabase...');
    
    // Tentar listar arquivos no bucket
    const { data: files, error: listError } = await supabaseAdmin.storage
      .from('whatsapp')
      .list('', { limit: 1 });
    
    if (listError) {
      console.error('‚ùå Erro ao acessar bucket:', listError);
      
      // Se o bucket n√£o existe, tentar criar
      if (listError.message.includes('not found') || listError.message.includes('does not exist')) {
        console.log('üì¶ Bucket n√£o encontrado, tentando criar...');
        
        // Nota: A cria√ß√£o de buckets via API n√£o √© suportada pelo Supabase
        // O bucket deve ser criado manualmente no painel do Supabase
        return res.status(404).json({ 
          error: 'Bucket "whatsapp" n√£o encontrado',
          message: 'Crie o bucket "whatsapp" manualmente no painel do Supabase Storage',
          instructions: [
            '1. Acesse o painel do Supabase',
            '2. V√° para Storage',
            '3. Clique em "New bucket"',
            '4. Nome: "whatsapp"',
            '5. P√∫blico: Sim (para URLs diretas)',
            '6. Clique em "Create bucket"'
          ]
        });
      }
      
      return res.status(500).json({ error: 'Erro ao acessar bucket', details: listError.message });
    }
    
    console.log('‚úÖ Bucket acess√≠vel, arquivos encontrados:', files?.length || 0);
    
    res.json({ 
      success: true, 
      message: 'Bucket acess√≠vel',
      filesCount: files?.length || 0
    });
    
  } catch (error) {
    console.error('‚ùå Erro na verifica√ß√£o do bucket:', error);
    res.status(500).json({ error: 'Erro interno do servidor', details: error.message });
  }
});

// Endpoint para sincroniza√ß√£o completa de perfis
app.post('/api/whatsapp-profile/:connectionId/sync-all', async (req, res) => {
  try {
    const { connectionId } = req.params;
    const { userId } = req.body;
    
    if (!userId) {
      return res.status(400).json({
        success: false,
        error: 'userId √© obrigat√≥rio'
      });
    }
    
    console.log('üîÑ [SYNC-ALL] Iniciando sincroniza√ß√£o completa de perfis:', { connectionId, userId });
    
    // Verificar se a conex√£o existe
    const connection = activeConnections.get(connectionId);
    if (!connection || !connection.sock) {
      return res.status(404).json({
        success: false,
        error: 'Conex√£o n√£o encontrada ou n√£o conectada'
      });
    }
    
    // Inicializar servi√ßo de sincroniza√ß√£o se n√£o estiver inicializado
    if (!profileSyncService.extractor) {
      profileSyncService.initialize(connection.sock);
    }
    
    // Executar sincroniza√ß√£o em background
    profileSyncService.syncAllProfiles(userId, connectionId)
      .then(() => {
        console.log('‚úÖ [SYNC-ALL] Sincroniza√ß√£o completa finalizada');
      })
      .catch(error => {
        console.error('‚ùå [SYNC-ALL] Erro na sincroniza√ß√£o:', error);
      });
    
    res.json({
      success: true,
      message: 'Sincroniza√ß√£o iniciada em background',
      data: {
        connectionId,
        userId,
        status: 'started'
      }
    });
    
  } catch (error) {
    console.error('‚ùå [SYNC-ALL] Erro:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Endpoint para sincronizar perfil de um contato espec√≠fico
app.post('/api/whatsapp-profile/:connectionId/sync-contact', async (req, res) => {
  try {
    const { connectionId } = req.params;
    const { userId, chatId } = req.body;
    
    if (!userId || !chatId) {
      return res.status(400).json({
        success: false,
        error: 'userId e chatId s√£o obrigat√≥rios'
      });
    }
    
    console.log('üîÑ [SYNC-CONTACT] Sincronizando contato espec√≠fico:', { connectionId, userId, chatId });
    
    // Verificar se a conex√£o existe
    const connection = activeConnections.get(connectionId);
    if (!connection || !connection.sock) {
      return res.status(404).json({
        success: false,
        error: 'Conex√£o n√£o encontrada ou n√£o conectada'
      });
    }
    
    // Inicializar servi√ßo de sincroniza√ß√£o se n√£o estiver inicializado
    if (!profileSyncService.extractor) {
      profileSyncService.initialize(connection.sock);
    }
    
    // Verificar se √© grupo ou contato individual
    const isGroup = chatId.includes('@g.us');
    
    if (isGroup) {
      await profileSyncService.syncGroupProfile(chatId, userId, connectionId);
    } else {
      await profileSyncService.syncContactProfile(chatId, userId, connectionId);
    }
    
    res.json({
      success: true,
      message: 'Contato sincronizado com sucesso',
      data: {
        connectionId,
        userId,
        chatId,
        isGroup
      }
    });
    
  } catch (error) {
    console.error('‚ùå [SYNC-CONTACT] Erro:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Endpoint para obter status da sincroniza√ß√£o
app.get('/api/whatsapp-profile/:connectionId/sync-status', async (req, res) => {
  try {
    const { connectionId } = req.params;
    
    console.log('üìä [SYNC-STATUS] Verificando status da sincroniza√ß√£o:', connectionId);
    
    const status = profileSyncService.getSyncStatus();
    
    res.json({
      success: true,
      data: {
        connectionId,
        ...status
      }
    });
    
  } catch (error) {
    console.error('‚ùå [SYNC-STATUS] Erro:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Endpoint para buscar informa√ß√µes de grupos
app.get('/api/whatsapp-profile/:connectionId/groups', async (req, res) => {
  try {
    const { connectionId } = req.params;
    
    console.log('üë• [GROUPS] Buscando informa√ß√µes de grupos:', connectionId);
    
    // Verificar se a conex√£o existe
    const connection = activeConnections.get(connectionId);
    if (!connection || !connection.sock) {
      return res.status(404).json({
        success: false,
        error: 'Conex√£o n√£o encontrada ou n√£o conectada'
      });
    }
    
    // Inicializar servi√ßo de sincroniza√ß√£o se n√£o estiver inicializado
    if (!profileSyncService.extractor) {
      profileSyncService.initialize(connection.sock);
    }
    
    // Buscar grupos
    const groups = await profileSyncService.extractor.fetchAllParticipatingGroups();
    
    res.json({
      success: true,
      data: {
        connectionId,
        groups: Object.keys(groups).map(groupId => ({
          id: groupId,
          subject: groups[groupId]?.subject || 'Grupo sem nome',
          participants: groups[groupId]?.participants?.length || 0,
          owner: groups[groupId]?.owner,
          creation: groups[groupId]?.creation
        }))
      }
    });
    
  } catch (error) {
    console.error('‚ùå [GROUPS] Erro:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Executar limpeza a cada hora
setInterval(cleanupOldSessions, 60 * 60 * 1000);

// Inicializar servidor
initializeServer();
